* [[ApiReference#wiki-Actor|Actor]]

* [[ApiReference#wiki-Aggregator|Aggregator]]

* [[ApiReference#wiki-Call|Call]]

* [[ApiReference#wiki-Campaign|Campaign]]

* [[ApiReference#wiki-Generator|Generator]]

* [[ApiReference#wiki-Lock|Lock]]

* [[ApiReference#wiki-MessageQueue|MessageQueue]]

* [[ApiReference#wiki-Mutex|Mutex]]

* [[ApiReference#wiki-Port|Port]]

* [[ApiReference#wiki-Promise|Promise]]

* [[ApiReference#wiki-ProxyActor|ProxyActor]]

* [[ApiReference#wiki-Selector|Selector]]

* [[ApiReference#wiki-Semaphore|Semaphore]]

* [[ApiReference#wiki-Signal|Signal]]

* [[ApiReference#wiki-Stage|Stage]]

* [[ApiReference#wiki-Task|Task]]

* [[ApiReference#wiki-Timeout|Timeout]]

* [[ApiReference#wiki-l8|l8]]


== Actor ==
* [[ApiReference#wiki-actorask|ask()]] - Ask something to an actor, ie also expect a response.
* [[ApiReference#wiki-actorbecome|become()]] - Change the way the actor handle the messages.
* [[ApiReference#wiki-actorreceive|receive()]] - Define the new behavior of actor for the next message.
* [[ApiReference#wiki-actorreply|reply]] - Async response to some "ask type" message.
* [[ApiReference#wiki-actortell|tell()]] - Send a message to this actor.

== Aggregator ==
* [[ApiReference#wiki-aggregatorpromise|promise]] - 
* [[ApiReference#wiki-aggregatorthen|then()]] - An aggregator is a promise too.

== Call ==
* [[ApiReference#wiki-callapply|apply()]] - Call a call, also resolve/reject its promise
* [[ApiReference#wiki-callcall|call()]] - Call a call, also resolve/reject its promise.
* [[ApiReference#wiki-callpromise|promise]] - Call can have a promise attached to them.
* [[ApiReference#wiki-callsignal|signal]] - Alias for .apply()
* [[ApiReference#wiki-callthen|then()]] - Calls are promises resolved/rejected when the call is called.

== Campaign ==
* [[ApiReference#wiki-campaignderegister|deregister()]] - 
* [[ApiReference#wiki-campaignlookup|lookup()]] - 
* [[ApiReference#wiki-campaignregister|register()]] - 

== Generator ==
* [[ApiReference#wiki-generatorclose|close()]] - 
* [[ApiReference#wiki-generatorget|get]] - 
* [[ApiReference#wiki-generatornext|next()]] - Block task until generator yields a result.
* [[ApiReference#wiki-generatorpromise|promise]] - The "can next()" promise of a generator.
* [[ApiReference#wiki-generatorput|put]] - 
* [[ApiReference#wiki-generatorthen|then()]] - A generator is also a promise, resolved when the generator yields a result.
* [[ApiReference#wiki-generatortry_next|try_next()]] - Like .next() but never blocks
* [[ApiReference#wiki-generatortry_yield|try_yield()]] - Like .yield() but never blocks.
* [[ApiReference#wiki-generatoryield|yield()]] - Task produce a new result and wait for consumer.

== Lock ==
* [[ApiReference#wiki-lockclose|close()]] - 
* [[ApiReference#wiki-lockpromise|promise]] - 
* [[ApiReference#wiki-lockrelease|release()]] - 
* [[ApiReference#wiki-locksignal|signal]] - 
* [[ApiReference#wiki-locktask|task]] - 
* [[ApiReference#wiki-lockthen|then()]] - 

== MessageQueue ==
* [[ApiReference#wiki-messagequeueclose|close()]] - 
* [[ApiReference#wiki-messagequeueempty|empty]] - 
* [[ApiReference#wiki-messagequeuefull|full]] - 
* [[ApiReference#wiki-messagequeueget|get()]] - 
* [[ApiReference#wiki-messagequeuein|in]] - 
* [[ApiReference#wiki-messagequeueout|out]] - 
* [[ApiReference#wiki-messagequeuepromise|promise]] - 
* [[ApiReference#wiki-messagequeueput|put()]] - 
* [[ApiReference#wiki-messagequeuesignal|signal]] - 
* [[ApiReference#wiki-messagequeuethen|then()]] - 
* [[ApiReference#wiki-messagequeuetry_get|try_get()]] - 
* [[ApiReference#wiki-messagequeuetry_put|try_put()]] - 

== Mutex ==
* [[ApiReference#wiki-mutexclose|close()]] - Close mutex, reject all pending promises.
* [[ApiReference#wiki-mutexpromise|promise]] - Mutexes queue promises that are resolved when mutex is entered.
* [[ApiReference#wiki-mutexrelease|release()]] - Release mutex, resolve next pending promise if any.
* [[ApiReference#wiki-mutexsignal|signal]] - Alias for Mutex.release()
* [[ApiReference#wiki-mutexthen|then()]] - A mutex is a promise, resolved when mutex is entered.

== Port ==
* [[ApiReference#wiki-portget|get()]] - 
* [[ApiReference#wiki-portin|in]] - 
* [[ApiReference#wiki-portout|out]] - 
* [[ApiReference#wiki-portpromise|promise]] - 
* [[ApiReference#wiki-portput|put()]] - 
* [[ApiReference#wiki-portsignal|signal]] - 
* [[ApiReference#wiki-portthen|then()]] - 
* [[ApiReference#wiki-porttry_get|try_get()]] - Like .get() but non blocking
* [[ApiReference#wiki-porttry_put|try_put()]] - Like .put() but non blocking

== Promise ==
* [[ApiReference#wiki-promisereject|reject()]] - Reject a promise, with a reason.
* [[ApiReference#wiki-promiseresolve|resolve()]] - Resolve a promise, with a result.
* [[ApiReference#wiki-promisesignal|signal]] - Alias for Promise##resolve()
* [[ApiReference#wiki-promisethen|then()]] - Attach callbacks to a promise.

== ProxyActor ==
* [[ApiReference#wiki-proxyactorask|ask()]] - Send a message to a remote actor, also expect a response
* [[ApiReference#wiki-proxyactordefer|defer()]] - Register callback to call when connection get lost
* [[ApiReference#wiki-proxyactortell|tell()]] - Send a message to a remote actor.
* [[ApiReference#wiki-proxyactorthen|then()]] - Register callbacks to call when connection succeeds xor fails

== Selector ==
* [[ApiReference#wiki-selectorpromise|promise]] - A selector has a promise attached to itself.
* [[ApiReference#wiki-selectorthen|then()]] - A selector is also a promise.

== Semaphore ==
* [[ApiReference#wiki-semaphoreclose|close()]] - Close semaphore, reject pending promises.
* [[ApiReference#wiki-semaphorepromise|promise]] - Make a new promise, queued, resolved when semaphore is released.
* [[ApiReference#wiki-semaphorerelease|release()]] - Add resource to semaphore, may resolve next pending promise.
* [[ApiReference#wiki-semaphoresignal|signal]] - Alias for Semaphore.release()

== Signal ==
* [[ApiReference#wiki-signalactive|active]] - A signal is active when some entities expects its occurence.
* [[ApiReference#wiki-signalclose|close()]] - CLose signal, reject pending promise.
* [[ApiReference#wiki-signalinactive|inactive]] - A signal is inactive when nothing is expecting its occurence.
* [[ApiReference#wiki-signalpromise|promise]] - Returns an unresolved promise that next a_signal.signal() will resolve.
* [[ApiReference#wiki-signalsignal|signal()]] - Signal the occurence of a signal.

== Stage ==
* [[ApiReference#wiki-stagedefer|defer()]] - Monitor loss of contact with a remote stage.
* [[ApiReference#wiki-stageget|get()]] - Get stage local variable.
* [[ApiReference#wiki-stageset|set()]] - Set stage local variable.

== Task ==
* [[ApiReference#wiki-taskaggregator = ProtoTask.all|aggregator = ProtoTask.all()]] - Make a promise that collects the outcome of sub promises
* [[ApiReference#wiki-taskbegin|begin]] - l8.begin creates a sub task. The task is not scheduled until .end is
* [[ApiReference#wiki-taskcallback |callback ]] - A f( err, rslt ) function that will reject/resolve the task's promise.
* [[ApiReference#wiki-taskcanceled|canceled]] - task.canceled is true if task.cancel() was called.
* [[ApiReference#wiki-taskcurrent|current]] -  return this
* [[ApiReference#wiki-taskdone|done]] - l8.done
* [[ApiReference#wiki-taskend|end]] - .end schedule a sub task defined using .begin.
* [[ApiReference#wiki-taskerror|error]] - l8.error
* [[ApiReference#wiki-taskfail|fail]] - l8.fail
* [[ApiReference#wiki-taskflow|flow]] - l8.flow is similar to l8.walk but it detects errors. ie it is a node.js
* [[ApiReference#wiki-taskgenerate|generate()]] - Make a new generator.
* [[ApiReference#wiki-taskid|id]] - 
* [[ApiReference#wiki-taskjoin|join()]] - 
* [[ApiReference#wiki-taskl8|l8]] - this.l8 is the root task in all code where "this" is bound to the current
* [[ApiReference#wiki-tasklabel|label]] - l8.label return the value of the "label" task local variable. That value
* [[ApiReference#wiki-tasklock|lock()]] - l8#lock()
* [[ApiReference#wiki-taskmutex|mutex()]] - A mutex is a binary semaphore.
* [[ApiReference#wiki-taskname|name]] - 
* [[ApiReference#wiki-taskparent|parent]] - l8.parent
* [[ApiReference#wiki-taskparents|parents]] - l8.parents
* [[ApiReference#wiki-taskpause|pause()]] - Pause execution of a task.
* [[ApiReference#wiki-taskport|port()]] - 
* [[ApiReference#wiki-taskpromise|promise]] - Tasks are promises.
* [[ApiReference#wiki-taskqueue|queue()]] - 
* [[ApiReference#wiki-taskraise|raise()]] - Raise an error inside a task.
* [[ApiReference#wiki-taskresult|result]] - l8.result
* [[ApiReference#wiki-taskresume|resume()]] - Resume execution of paused task.
* [[ApiReference#wiki-taskroot|root]] - l8.root
* [[ApiReference#wiki-taskselector|selector()]] - L8#selector()
* [[ApiReference#wiki-tasksignal|signal()]] - Alias for task.resume()
* [[ApiReference#wiki-taskstopped|stopped]] - l8.stopped
* [[ApiReference#wiki-taskstopping|stopping]] - l8.stopping
* [[ApiReference#wiki-tasksucceed|succeed]] - l8.succeed
* [[ApiReference#wiki-tasktasks|tasks]] - l8.tasks
* [[ApiReference#wiki-taskthen|then()]] - Tasks are promises, resolved/rejected when tasks succeeds/fails.
* [[ApiReference#wiki-tasktimeout|timeout()]] - Make a new timeout that will bomb after a delay.
* [[ApiReference#wiki-tasktoString = ProtoTask.toLabel|toString = ProtoTask.toLabel()]] - Task object have a .toString() and .toLabel() methods that provide a
* [[ApiReference#wiki-tasktrace|trace]] - 
* [[ApiReference#wiki-taskwait|wait()]] - 
* [[ApiReference#wiki-taskwalk|walk]] - l8.walk is used to pause/resume the current task when an async call is done.

== Timeout ==
* [[ApiReference#wiki-timeoutduration|duration]] - How long since timeout was created or until it fired.
* [[ApiReference#wiki-timeoutpromise|promise]] - Return the promise that is resolved when the timeout fires.
* [[ApiReference#wiki-timeoutsignal|signal()]] - Fire timeout early.
* [[ApiReference#wiki-timeoutsignaled|signaled]] - Time when timeout was fired, or null
* [[ApiReference#wiki-timeoutstarted|started]] - Time when the timeout was created. ie: l8.now at that time.
* [[ApiReference#wiki-timeoutthen|then()]] - Timeouts are promises resolved withing a fixed delay.

== l8 ==
* [[ApiReference#wiki-l8Role|Role()]] - 
* [[ApiReference#wiki-l8Task|Task()]] - Build a "task constructor". 
* [[ApiReference#wiki-l8__defineGetter__|__defineGetter__()]] - As a convention, methods applied on the global root task l8 are forwared to
* [[ApiReference#wiki-l8actor|actor()]] - l8.actor()
* [[ApiReference#wiki-l8and|and()]] - l8.and()
* [[ApiReference#wiki-l8any|any()]] - l8.any()
* [[ApiReference#wiki-l8assert|assert()]] - l8.assert( cond ) raises an error when cond is satisfied.
* [[ApiReference#wiki-l8binding|binding()]] - Return the "binding" where a variable is stored.
* [[ApiReference#wiki-l8break|break()]] - ToDo: l8.break( [val] )
* [[ApiReference#wiki-l8bug|bug()]] - l8.bug() is an alias for l8.trace() that enables the de&&bug() pattern.
* [[ApiReference#wiki-l8call|call()]] - Create a function whose result will resolve a promise.
* [[ApiReference#wiki-l8callback|callback()]] - Register a node style callback called on promise's completion.
* [[ApiReference#wiki-l8client|client()]] - True when running inside a browser. Opposite to l8.server.
* [[ApiReference#wiki-l8clientize|clientize()]] - Act as if client. Override l8.client/l8.server auto-detection. 
* [[ApiReference#wiki-l8compile|compile()]] - l8.compile() may need to be provided a well scoped "eval()" or else it's
* [[ApiReference#wiki-l8compileGenerator|compileGenerator()]] - l8.compileGenerator( fn )
* [[ApiReference#wiki-l8compiler|compiler()]] - l8.compiler( fn )
* [[ApiReference#wiki-l8continue|continue()]] - ToDo: l8.continue( [val] )
* [[ApiReference#wiki-l8countdown|countdown()]] - Exit process with error status 1 after a while.
* [[ApiReference#wiki-l8dateNow|dateNow()]] - l8.dateNow is the Date object sampled when l8.now was last sampled.
* [[ApiReference#wiki-l8debug|debug()]] - DEBUG mode currently defaults to "on". Please use l8.debug() to change it
* [[ApiReference#wiki-l8defer|defer()]] - l8.defer( fn ) pushes a function to execute when the current task is about
* [[ApiReference#wiki-l8failure|failure()]] - Some special errors are used to build control structures.
* [[ApiReference#wiki-l8final|final()]] - l8.final( fn )
* [[ApiReference#wiki-l8fork|fork()]] - Queue a step that starts a forked task. forks "join".
* [[ApiReference#wiki-l8http_port|http_port()]] - To expose the local actors to the outside world, an http server is required.
* [[ApiReference#wiki-l8inspect|inspect()]] - l8.inspect( obj ) returns a string representation for the specified object
* [[ApiReference#wiki-l8label|label()]] - l8.label = "xxx" sets the "label" thread local variable. That variable can
* [[ApiReference#wiki-l8logger|logger()]] - l8.logger( null ) restores the default logger for traces.
* [[ApiReference#wiki-l8mand|mand()]] - l8.mand( cond ) is an alias for l8.trace() that enable the de&&mand()
* [[ApiReference#wiki-l8next|next()]] - Yield a new result for the active generator's consumer.
* [[ApiReference#wiki-l8now|now()]] - l8.now provides a fast access to the time in millisec. That value is
* [[ApiReference#wiki-l8parentTask|parentTask()]] - Bootstrap root task, id 0
* [[ApiReference#wiki-l8pause|pause()]] - l8.paused
* [[ApiReference#wiki-l8proceed|proceed()]] - l8.proceed( fn ) is used to pause/resume a task when dealing with async
* [[ApiReference#wiki-l8promise|promise()]] - Create a new promise.
* [[ApiReference#wiki-l8promise_factory|promise_factory()]] - Use another promise factory, not l8's one.
* [[ApiReference#wiki-l8proto|proto()]] - l8.proto makes it easy for module to export a new mmm method by adding it
* [[ApiReference#wiki-l8proxy|proxy()]] - 
* [[ApiReference#wiki-l8repeat|repeat()]] - l8.repeat( fn )
* [[ApiReference#wiki-l8result|result()]] - l8.result = val assigns a new result to the task. If some step remains to
* [[ApiReference#wiki-l8return|return()]] - l8.return( [val] )
* [[ApiReference#wiki-l8server|server()]] - True when running inside node.js. Opposite to l8.client.
* [[ApiReference#wiki-l8serverize|serverize()]] - Act as if server. Override l8.client/l8.server auto-detection. 
* [[ApiReference#wiki-l8set|set()]] - l8#get()
* [[ApiReference#wiki-l8stage|stage()]] - Monitor contact with a remote stage.
* [[ApiReference#wiki-l8step|step()]] - Pause task for specified delay, milli-seconds.
* [[ApiReference#wiki-l8stop|stop()]] - l8.stop() set a flag for the task, asking it to stop gently.
* [[ApiReference#wiki-l8success|success()]] - l8.success( fn )
* [[ApiReference#wiki-l8task|task()]] - Queue a step in the task's step queue.
* [[ApiReference#wiki-l8tick|tick()]] - l8.tick( fn ) is a low level function that schedules the execution of a
* [[ApiReference#wiki-l8trace|trace()]] - User can redefine what logger l8.trace() uses, see l8.logger().
* [[ApiReference#wiki-l8try_yield|try_yield()]] - Alias for l8.try_yield()
* [[ApiReference#wiki-l8var|var()]] - Create a "task local" variable.
* [[ApiReference#wiki-l8wait|wait()]] - Make a new semaphore.

----


== Actor ==


=== actor.ask() ===
'Ask something to an actor, ie also expect a response.'


Usage:
```javascript

  an_actor.ask( "Do", "something" )
  an_actor.ask( ["Do","something"], function( err, rslt ){...} )
```

Send an 'ask type' message to the actor. The actor should reply.
Optional function( err, rslt ) is called with the outcome. If not provided,
a promise is returned instead.

To reply, the actor can:
  1/ provide an immediate result, by returning it.
  2/ return a promise that it will fulfill later.
  3/ return nothing immediately and produce a result later. To do that,
  the actor is provided a reply callback that it must call with the outcome,
  ie either an error or a null error and a result. The callback that the actor
  must call is accessible using an_actor.reply. The actor for which the
  current task is running is accessible using this.ego. When the actor uses
  this method, ie when it accesses this.ego.reply, it means that the actor
  is ok to process another message. As a result, many requests can be
  processed in parallel instead of in sequence as it is the case when the
  actor returns a promise. Note: the actor can store the reply callback, it
  then can call it later, to provide an answer, maybe after it has processed
  some other messages.

=== actor.become() ===
'Change the way the actor handle the messages.'

Usage:
```javascript

  this.ego.become( function )
  this.ego.become( behavior )
```

The way an actor processes the messages is initialy defined when the actor
is first created. However, the actor can change this at any time.

This can be usefull for actors that accept or queue different messages
depending on their internal state. When the state change, the actor can
change behavior.

See also [[ApiReference#wiki-Actorreceive|Actor#receive]]() when an actor needs to change the way it handles
just one message.

=== actor.receive() ===
'Define the new behavior of actor for the next message.'

Usage:
```javascript

  this.ego.receive( function )
  this.ego.receive( behavior, options )
```

When an unexpected message is received, it gets queued. Whenever the actor
attempts to receive a new message, these queued messages are proposed first.
Such queued messages are a backlog and it is the programmer's responsability
to make sure that the backlog does not grow much or else performances will
suffer.

The actor is normally idle, unless a timeout was specified (option).
If some revious message was left unprocessed, the actor will process
them if it wants. Or else, the actor waits for a new message to come in.
When the special timeout value 0 is specified, only old messages are
processed.

option { timeout: xx, after: function() } specifies what function to call if
no message is received within the specified delay.

When the actor behavior depends on the reception of a single specific
message, once that message is received, the actor gets back to its previous
behavior. To change the behavior for more than one message, see Actor#become.

=== actor.reply ===
'Async response to some "ask type" message.'


Usage:
```javascript

  var reply = this.ego.reply
  ...
  reply( err, rslt )
```

By default, actors process messages in sequence. However, if an actor
wants to process messages in parallel, it can store a reply callback
and reply later. When the actor gets the reply callback, l8 detects that and
unlock the mailbox of the actor.

=== actor.tell() ===
'Send a message to this actor.'

Usage:
```javascript

  an_actor.tell( "Seen", "something" )
  an_actor.tell( ["Seen", "something"], function( err ){...} )
```

Optional function( err ) is a callback. If it is not provided, a promise 
is returned instead. The only possible error is when an attempt is
made to send a message to a dead/done actor or to a remote actor when the
contact is lost.


== Aggregator ==


=== aggregator.promise ===
''


=== aggregator.then() ===
'An aggregator is a promise too.'



== Call ==


=== call.apply() ===
'Call a call, also resolve/reject its promise'


=== call.call() ===
'Call a call, also resolve/reject its promise.'


=== call.promise ===
'Call can have a promise attached to them.'


=== call.signal ===
'Alias for .apply()'

When a call object is signaled, the call's function is called.

=== call.then() ===
'Calls are promises resolved/rejected when the call is called.'

If the calls raises an exception, the promise is rejected. Or else, the
the promise is resolved using the result of the call.


== Campaign ==


=== campaign.deregister() ===
''


=== campaign.lookup() ===
''


=== campaign.register() ===
''



== Generator ==


=== generator.close() ===
''


=== generator.get ===
''


=== generator.next() ===
'Block task until generator yields a result.'

Optional parameter is sent to the generator. It gets it as the result of
the step that called .yield().

=== generator.promise ===
'The "can next()" promise of a generator.'

The default promise of a generator is the promise resolved when the consumer
can get a new result without blocking.
See also [[ApiReference#wiki-Generatorset|Generator.set]] about the promise resolved when the generator can
yield a new result without being blocked.

=== generator.put ===
''


=== generator.then() ===
'A generator is also a promise, resolved when the generator yields a result.'

After the generator yields a result and resolve its promise, a new promise
becomes pending.

=== generator.try_next() ===
'Like .next() but never blocks'


=== generator.try_yield() ===
'Like .yield() but never blocks.'

Returns [false] or [true,message]

=== generator.yield() ===
'Task produce a new result and wait for consumer.'

The value returned is what the consumer specified when it called .next(),
or the undefined value if it specified nothing.


== Lock ==


=== lock.close() ===
''


=== lock.promise ===
''


=== lock.release() ===
''


=== lock.signal ===
''


=== lock.task ===
''


=== lock.then() ===
''



== MessageQueue ==


=== messagequeue.close() ===
''


=== messagequeue.empty ===
''


=== messagequeue.full ===
''


=== messagequeue.get() ===
''


=== messagequeue.in ===
''


=== messagequeue.out ===
''


=== messagequeue.promise ===
''


=== messagequeue.put() ===
''


=== messagequeue.signal ===
''


=== messagequeue.then() ===
''

Signals are promises that detect events. Repeatedly.

When a signal is signaled, it's current promise is resolved and a new
promise is attached to it when a_signal.then() is called again.
As a result, a_signal.then() is guarantee to succeed only when the next
a_signal.signal() occurs.
Note: when an unresolved promise is attached to a signal, the signal is
active. After the signal is signaled, it becomes inactive, until it is
activated again.

=== messagequeue.try_get() ===
''


=== messagequeue.try_put() ===
''



== Mutex ==


=== mutex.close() ===
'Close mutex, reject all pending promises.'


=== mutex.promise ===
'Mutexes queue promises that are resolved when mutex is entered.'

Note: accessing .promise twice results in two more promises in the promise
of of the mutex. I.e. make there that each promise, when resolved,
eventually releases the mutex, or else queued promises will never be
resolved.
If the same task tries to reacquire a mutex, an exception is raised.
That is not the case with re-entrant mutexe, See also [[ApiReference#wiki-Lockpromise|Lock.promise]]

=== mutex.release() ===
'Release mutex, resolve next pending promise if any.'


=== mutex.signal ===
'Alias for Mutex.release()'


=== mutex.then() ===
'A mutex is a promise, resolved when mutex is entered.'

Duck typing so that Task.wait() works.


== Port ==


=== port.get() ===
''


=== port.in ===
''


=== port.out ===
''


=== port.promise ===
''


=== port.put() ===
''


=== port.signal ===
''


=== port.then() ===
''


=== port.try_get() ===
'Like .get() but non blocking'


=== port.try_put() ===
'Like .put() but non blocking'



== Promise ==


=== promise.reject() ===
'Reject a promise, with a reason.'


=== promise.resolve() ===
'Resolve a promise, with a result.'


=== promise.signal ===
'Alias for Promise##resolve()'


=== promise.then() ===
'Attach callbacks to a promise.'


Usage:
```javascript

 a_promise.then(
   function( rslt ){ ... },
   function( err  ){ ... }
}
```

See http://promises-aplus.github.com/promises-spec/

The returned value is a new promise. That promise will be resolved with
the result of the attached callbacks. If that result is an exception, the
new promise is rejected, the reason is the exception.


== ProxyActor ==


=== proxyactor.ask() ===
'Send a message to a remote actor, also expect a response'


Usage:
```javascript

  actor.ask( "Some", "question" ).then( function( r ){ console.log( r ) } )
```

If the contact is lost or if the remote actor replied with an error, the
promise is rejected.

=== proxyactor.defer() ===
'Register callback to call when connection get lost'


=== proxyactor.tell() ===
'Send a message to a remote actor.'


Usage:
```javascript

  var promise = remote_actor.tell( "See", "you" )
  promise.then( null, function( ko ){ console.log( "Contact was lost" ) } )
```


=== proxyactor.then() ===
'Register callbacks to call when connection succeeds xor fails'



== Selector ==


=== selector.promise ===
'A selector has a promise attached to itself.'


=== selector.then() ===
'A selector is also a promise.'



== Semaphore ==


=== semaphore.close() ===
'Close semaphore, reject pending promises.'


=== semaphore.promise ===
'Make a new promise, queued, resolved when semaphore is released.'


=== semaphore.release() ===
'Add resource to semaphore, may resolve next pending promise.'


=== semaphore.signal ===
'Alias for Semaphore.release()'



== Signal ==


=== signal.active ===
'A signal is active when some entities expects its occurence.'

I.e. a signal is active when there is a pending promise. When an active
signal is signaled, the promise is resolved.

=== signal.close() ===
'CLose signal, reject pending promise.'


=== signal.inactive ===
'A signal is inactive when nothing is expecting its occurence.'

An event occurence signaled on a inactive signal object is ignored.

=== signal.promise ===
'Returns an unresolved promise that next a_signal.signal() will resolve.'

Returns an already rejected promise if signal was closed.

=== signal.signal() ===
'Signal the occurence of a signal.'

Tasks that block on the signal are deblocked.
Also resolves the promise attached to the signal. Signals are not
buffered, the first signaled value is the value of the current promise.
If another signal occurs before another promise is issued, it get lost.
Ie, signaling an inactive signal is a noop.
A new promise is issued when a_signal.then() is called, if the current
promise is already resolved.


== Stage ==


=== stage.defer() ===
'Monitor loss of contact with a remote stage.'


Usage:
```javascript

  this.ego.stage.defer( function(){ "client disconnected" } )
```

Note: multiple calls to .defer() will result in multiple functions being
called when the contact with that stage gets lost.

=== stage.get() ===
'Get stage local variable.'


=== stage.set() ===
'Set stage local variable.'



== Task ==


=== task.aggregator = ProtoTask.all() ===
'Make a promise that collects the outcome of sub promises'

The promise is never rejected. Instead, its value is an array of "results"
where each result is [err,rslt] for the corresponding promise.

=== task.begin ===
'l8.begin creates a sub task. The task is not scheduled until .end is'

mentionned. Nested tasks are possible. .begin is useful to handle errors
like javascript does with try/catch.
Usage: l8.begin.step(...).step(...).end

=== task.callback  ===
'A f( err, rslt ) function that will reject/resolve the task's promise.'


=== task.canceled ===
'task.canceled is true if task.cancel() was called.'


=== task.current ===
' return this'


=== task.done ===
'l8.done'

task.done is true when the task is done, ie terminated.

=== task.end ===
'.end schedule a sub task defined using .begin.'

Returns parent to make chaining possible: t.begin.step().step().end.step()

=== task.error ===
'l8.error'

task.error is the last error for the task. Null if none.

=== task.fail ===
'l8.fail'

task.fail is true when a task is done but failed, due to some error.

=== task.flow ===
'l8.flow is similar to l8.walk but it detects errors. ie it is a node.js'

friendly "walk" that checks first result to detect errors and throw
error when present, or else filters out first result to set result of step
using rest.

=== task.generate() ===
'Make a new generator.'


=== task.id ===
''


=== task.join() ===
''


=== task.l8 ===
'this.l8 is the root task in all code where "this" is bound to the current'

task.

=== task.label ===
'l8.label return the value of the "label" task local variable. That value'

can be useful to output traces.

=== task.lock() ===
'l8#lock()'

A create a new lock, a re-entrant mutex

=== task.mutex() ===
'A mutex is a binary semaphore.'

See http://en.wikipedia.org/wiki/Mutual_exclusion

=== task.name ===
''


=== task.parent ===
'l8.parent'

task.parent is the parent task to the specified task.

=== task.parents ===
'l8.parents'

task.parents is an array of tasks starting from the specified task and
ending with the top root task, with all the intermediary tasks in between.

=== task.pause() ===
'Pause execution of a task.'

Task will resume and execute next step when resume() is called.

=== task.port() ===
''


=== task.promise ===
'Tasks are promises.'


=== task.queue() ===
''


=== task.raise() ===
'Raise an error inside a task.'

Note: val parameter is needed when err is l8.returnEvent

=== task.result ===
'l8.result'

task.result is the result of a task. If the task is not finished, it is
the last result produced by a step in that task.

=== task.resume() ===
'Resume execution of paused task.'

Execution restarts at step next to the one where the task was paused.

When provided a value, that value will be the input for the next step.
See also [[ApiReference#wiki-l8paused|l8.paused]].

=== task.root ===
'l8.root'

task.root is, among task.parents, the task just below the topmost l8 task.

=== task.selector() ===
'L8#selector()'

Make a selector promise, resolved when one of many promises resolves.

=== task.signal() ===
'Alias for task.resume()'


l8#signal()
Make a new signal. Signals are activable event detectors.
Signals can be signaled multiple times. When a signal is
signaled, the promise attached to it is resolved and a new promise can be
attached to it (that will be resolved when the signal is signaled again).
Note: if the signal occurs while nobody cares, it get lost, ie signals are
event detectors, when inactive they detect nothing.
Note: a new promise is attached to a signal using .promise or .then() ;
this "clears" the previously signaled signal and reactivate the signal, ie
it restarts the event detection.

=== task.stopped ===
'l8.stopped'

task.stopped is true if a task is done and was asked to terminate using
task.stop

=== task.stopping ===
'l8.stopping'

task.stopping is true if task is not terminated but was asked to terminate
because task.stop() was called.

=== task.succeed ===
'l8.succeed'

task.succeed is true when the task is done and did not fail.

=== task.tasks ===
'l8.tasks'

task.tasks returns an array with one item for each direct sub task of the
specified task.

=== task.then() ===
'Tasks are promises, resolved/rejected when tasks succeeds/fails.'


=== task.timeout() ===
'Make a new timeout that will bomb after a delay.'


=== task.toString = ProtoTask.toLabel() ===
'Task object have a .toString() and .toLabel() methods that provide a'

value that can be useful to output trace messages when debugging.
See also [[ApiReference#wiki-l8label|l8.label]] to get/set the user label associated to a task.

=== task.trace ===
''


=== task.wait() ===
''


=== task.walk ===
'l8.walk is used to pause/resume the current task when an async call is done.'

It provides a callback that will use its parameter to set the output of
the step, an output that will become the input of the next step.


== Timeout ==


=== timeout.duration ===
'How long since timeout was created or until it fired.'


=== timeout.promise ===
'Return the promise that is resolved when the timeout fires.'


=== timeout.signal() ===
'Fire timeout early.'

Resolves the promise of the timeout early.

=== timeout.signaled ===
'Time when timeout was fired, or null'


=== timeout.started ===
'Time when the timeout was created. ie: l8.now at that time.'


=== timeout.then() ===
'Timeouts are promises resolved withing a fixed delay.'

It is possible to fire them early, using to.signal().


== l8 ==


=== l8.Role() ===
''


=== l8.Task() ===
'Build a "task constructor". '


Usage:
```javascript

  var do_it = l8.Task( function( p1, p2, ... ){...} }
  do_it( "Just", "the maximum" )
```

A task constructor is, at the step level, the equivalent of a "function" at
the javascript statement level. I.e. calling a task constructor and calling
a function are similar actions.

When a task constructor is called, it creates a task with the supplied 
parameters and returns a promise that will be resolved or rejected depending
on the task outcome. The task that calls the task constructor waits for that
promise to be fulfilled.

Return a "Generator Constructor".
This function behaves much like l8.Task() does but the returned
value is a Generator Task, not just a regular Task. I.e. it can "yield".

=== l8.__defineGetter__() ===
'As a convention, methods applied on the global root task l8 are forwared to'

the "current task". For normal task, .current is simply an attribute whose
value never changes and is a reference to the object itself, ie obj.current
== obj

=== l8.actor() ===
'l8.actor()'

Look up for an actor or create one (or create an actor generator).
Usage:
```javascript

  l8.actor( name )      -- look for a local actor or a known remote actor
  l8.actor( name, url ) -- return a proxy to access a remote actor
  l8.actor( name, function ) -- create an actor, managed by a function
  l8.actor( name, behavior ) -- idem with an initial behavior
```

When the name ends with a dot, it is an actor generator that is returned.
When that generator is called, a new actor is created, whose name is the
actor generator name plus a sequential number.

Actors behaviors are described in Actor#receive()

l8#actor

Usage:
```javascript

  var remote_actor = l8.actor( "service", "http://some.server.com" )
```

Remote actors and local actors both provide a .tell() and .ask() methods so
that for most usage, they are identical.
See also [[ApiReference#wiki-ProxyActorthen|ProxyActor#then]]() and [[ApiReference#wiki-ProxyActordefer|ProxyActor#defer]]() about contact monitoring
because things are sligthly different when the actor is remote.

l8.actor()
Look up for an existing proxied actor.

Usage:
```javascript

  var actor = l8.actor( "service" )
```

If an actor with the specified name was referenced before, it is that object
which is returned. Or else, null is returned.

=== l8.and() ===
'l8.and()'

Make a promise that depends on sub promises.

=== l8.any() ===
'l8.any()'

Alias for l8.selector()
See also [[ApiReference#wiki-l8or|l8.or]]()

L8#or()
Make a promise resolved when one of many promises resolves with thruth. If
one of the sub promises is rejected, the whole promise is rejected.
See also [[ApiReference#wiki-l8any|l8.any]]()

=== l8.assert() ===
'l8.assert( cond ) raises an error when cond is satisfied.'


=== l8.binding() ===
'Return the "binding" where a variable is stored.'


Usage:
```javascript

  var vars = l8.binding();
  var task = vars.task;
  for( name in vars ){
    if( name === "task" )continue;
    if( vars[name].task ){
      console.log( "task " + task + " accesses " + name
      + " defined by parent task " + vars[name].task );
    }else{
      console.log( "task " + task + " defines " + name );
    }
  }
```

Usage:
```javascript

 var manager = l8.binding( "session" ).task
```

A binding is an object with a "task" property (the binding owner) and
a property for each variable ever accessed by that task or it's sub tasks.
Such properties have a "value" property when that variable is stored directly
inside that binding. Or else they have a "task" property that tells which task
actually stores the variable's value.

See also [[ApiReference#wiki-l8var|l8.var]]().

=== l8.break() ===
'ToDo: l8.break( [val] )'

l8.break
task.break raises a l8.breakEvent in the specified task. That exception is
propagated to the parent tasks, up to a task where l8.repeat() is active.
That loop is then terminated.

=== l8.bug() ===
'l8.bug() is an alias for l8.trace() that enables the de&&bug() pattern.'


=== l8.call() ===
'Create a function whose result will resolve a promise.'

The first parameter is a function. The second parameter is what "this" will
be bound to when that function is called/signaled, it is optional.

The returned function is also a promise, ie it implements .then().
The promise is resolved/rejected when the function is called, using its
result.

Note: this promise resolution is invisible to the entity that calls the
function, the result xor exception are returned as if the function was a
regular function, called synchronously (the promise callbacks are called
later, async).

Usage:
```javascript

  var f = l8.call( function( msg ){ return this.handle( msg ) }, handler )
  f.then( function( r ){ console.log( r,  "world!" ); } )
  ...
  console.log( f( "Hello" ) );
```

Usage:
```javascript

  l8.step( function(){
    var read
    fs.readFile( "xx", "utf8", read = l8.call( function( err, rslt ){
      if( err ) throw err;
      return rslt
    }
    return read
  }).step( function( r ){ console.log( "content of xx: " + r ); })
```

When the pending call is eventually called, the promise attached to it is
resolved/rejected, depending on the outcome of the call.

=== l8.callback() ===
'Register a node style callback called on promise's completion.'


Usage:
```javascript

 l8.callback( a_promise, function( err, rslt ){ ... } )
```

Usage:
```javascript

  a_task.callback( function( err, rslt ){ ... } )
Promise defaults to current task when not specified.
```

In both cases, the returned value is a promise.
See also [[ApiReference#wiki-Promisethen|Promise#then]]()

=== l8.client() ===
'True when running inside a browser. Opposite to l8.server.'


=== l8.clientize() ===
'Act as if client. Override l8.client/l8.server auto-detection. '


=== l8.compile() ===
'l8.compile() may need to be provided a well scoped "eval()" or else it's'

result function may lack access to the global variables referenced by the
code to (re)compile. This should be necessary on nodejs only, not in browsers


=== l8.compileGenerator() ===
'l8.compileGenerator( fn )'

This method compiles a generator constructor using the source of the
specified "fn" function

=== l8.compiler() ===
'l8.compiler( fn )'

Expand some macros to make a "task constructor" or a "generator constructor".

=== l8.continue() ===
'ToDo: l8.continue( [val] )'

l8.continue
task.continue raises a l8.continueEvent in the task. That exception is
propagated to the parent tasks, up to a task where l8.repeat() is active.
That loop is then reentered.  

=== l8.countdown() ===
'Exit process with error status 1 after a while.'

Displays a stressfull message every second until that.

=== l8.dateNow() ===
'l8.dateNow is the Date object sampled when l8.now was last sampled.'


=== l8.debug() ===
'DEBUG mode currently defaults to "on". Please use l8.debug() to change it'


l8.debug() returns true of false depending on the debug flag setting.
l8.debug( v ) sets that flag to true or false.

l8.de&&bug( ... ), where "l8.de" changes according to l8.debug()

=== l8.defer() ===
'l8.defer( fn ) pushes a function to execute when the current task is about'

to terminate. These functions are executed in LIFO order. See documentation
about the difference between .defer() and .final()

=== l8.failure() ===
'Some special errors are used to build control structures.'

l8.cancelEvent is the value of the parameter for the l8.failure() specified
function when the failure is due to a cancellation.

task.cancel() terminates the specified task and its sub tasks. When a task
get canceled, a l8.cancelEvent exception is raised. That error can be
captured with l8.failure() and l8.final().
After a task.cancel(), task.canceled is true.

l8.failure( fn )
task.failure() specifies a function to be called when the task terminates.
The function receives a paremeter, l8.error, the last error.
The function is called only if the task is failing. It is called before
the function specified using l8.final()

=== l8.final() ===
'l8.final( fn )'

task.final() specifies a function to be called when the task terminates. The
function receives two paremeters. The first one is l8.error, the last error,
the second one is l8.result, the last result.

=== l8.fork() ===
'Queue a step that starts a forked task. forks "join".'


l8.fork() is similar to l8.task() but makes it possible to run multiple
sub tasks in parallel. The result of each forked task is accumulated into an
array, respecting the forked tasks creation order. That array becomes the
input of the next step.

Usage:
```javascript

  l8.fork( function(      ){  return "a";
  }).fork( function(      ){  return "b";
  }).step( function( a, b ){  return a + b;
  }).then( function( ab   ){  console.log( ab ); })
```

See also [[ApiReference#wiki-l8spawn|l8.spawn]]().

=== l8.http_port() ===
'To expose the local actors to the outside world, an http server is required.'

If none is provided, one will be created, using the specified port or a
reasonnable default one that depends on the running platform.

=== l8.inspect() ===
'l8.inspect( obj ) returns a string representation for the specified object'

that can be useful to output traces.

=== l8.label() ===
'l8.label = "xxx" sets the "label" thread local variable. That variable can'

be useful in trace messages.

=== l8.logger() ===
'l8.logger( null ) restores the default logger for traces.'

This is the function that returns the default log() function that l8.trace()
uses. That returned function must have the signature of console.log()

=== l8.mand() ===
'l8.mand( cond ) is an alias for l8.trace() that enable the de&&mand()'

pattern for asserts that can be disabled with very little overhead left.

=== l8.next() ===
'Yield a new result for the active generator's consumer.'

See also [[ApiReference#wiki-Generatoryield|Generator.yield]]() when in need of nested generator.
See also [[ApiReference#wiki-l8next|l8.next]]() about how to receive results.

l8.next()
Consume another result from the active peer generator.
See also [[ApiReference#wiki-Generatornext|Generator.next]]() when in need of nested generators.

=== l8.now() ===
'l8.now provides a fast access to the time in millisec. That value is'

sample whenever the l8 scheduler wakes up. As a result, it can be
usefull to correlate sub events that pertain to the same evant that
woke up the scheduler.

=== l8.parentTask() ===
'Bootstrap root task, id 0'


=== l8.pause() ===
'l8.paused'

task.paused is true if the specified task is paused. See l8.pause() &
l8.resume()

=== l8.proceed() ===
'l8.proceed( fn ) is used to pause/resume a task when dealing with async'

functions. The fn function is called with the parameters provided by the
async function. The returned value of that fn function, unless undefined,
provide the output for the step, an output that will be input for the next
step. See also [[ApiReference#wiki-l8walk|l8.walk]] and [[ApiReference#wiki-l8flow|l8.flow]] that are simpler to use in most cases.
Usage:
 l8.step( function(){ fs.readFile( "xx", "utf8",
   l8.proceed( function( err, content ){ return [err,content]; })
Pauses current task and returns a callback to be called to resume execution.

=== l8.promise() ===
'Create a new promise.'

See Promise#then()

a function( err, rslt ) that will resolve or reject the promise.

Usage:
```javascript

  var read = l8.promise();
  fs.readFile( "xx", "utf8", read.callback );
  read.then( function( content ){ console.log( "xx:" + content ); } );
```


=== l8.promise_factory() ===
'Use another promise factory, not l8's one.'


Usage:
```javascript

 l8.promise_factory( require( "Q" ).defer );
```


=== l8.proto() ===
'l8.proto makes it easy for module to export a new mmm method by adding it'

to the prototype of all the task objects. As a result this.mmm() will be
directly accessible in the code body of all tasks, ie where "this" is bound
to the current task.

=== l8.proxy() ===
''


=== l8.repeat() ===
'l8.repeat( fn )'

Add a step that will repeately execute the specified function. Please use
l8.break to exit that loop.

=== l8.result() ===
'l8.result = val assigns a new result to the task. If some step remains to'

be executed, that result will be the input for the step.

=== l8.return() ===
'l8.return( [val] )'

task.return() terminates the specified task. Sub tasks are left untouched.
In the task, execution jumps to the deferred clause and .final() clause.

=== l8.server() ===
'True when running inside node.js. Opposite to l8.client.'

Note: detection is currently based on success of require( "util" ).

=== l8.serverize() ===
'Act as if server. Override l8.client/l8.server auto-detection. '


=== l8.set() ===
'l8#get()'

Get the value of a task's variable.
If the current task does not define that variable in it's own binding,
follow binding chain in parent task.
See also [[ApiReference#wiki-l8set|l8.set]]()

=== l8.stage() ===
'Monitor contact with a remote stage.'

Usage:
 var stage = l8.stage( "http//some.server.com" ).then(
   function( ok ){ remote_actor = l8.actor( "service", stage ),
   function( ko ){ console.log( "Cannot contact server", ko ) }
 )
A stage is a promise that is resolved when the contact is established or
is rejected if the contact cannot be established.
To handle the loss of an established contact, see Stage#defer()

l8.stage()
Set up contact with a remote stage.

Usage:
```javascript

  var stage = l8.stage( "http://some.server.com" )
  var actor = l8.actor( "service", stage )
```


=== l8.step() ===
'Pause task for specified delay, milli-seconds.'


Usage:
```javascript

  l8.step( function(){ l8.sleep( 1000 ); } );
```

Semaphores are queued promises, resolved when semaphore is released.
Usage:
```javascript

 l8.step(  function(){  l8.wait( a_semaphore );
 )}.step(  function(){  console.log( "resource acquired" );
 }).step(  function(){  ...
 }).final( function(){  a_semaphore.release(); })
```

Usage:
```javascript

 a_semaphore.then( function(){ console.log( "resource acquired" ); } );
```

See also [[ApiReference#wiki-Promisethen|Promise.then]]()

l8#select()
Block task until one of many promises delivers.

Usage:
```javascript

  l8.step( function(){
    var timeout = l8.timeout( 1000 );
    var read
    fs.readFile( "xx", "utf8", read = l8.call( function( err, rslt ){
      return [err,rslt]
    });
    l8.select( read, timeout )
  }).step( function( err, rslt ){ if( err ){ ... }else{ ...use rslt... } )}
```


=== l8.stop() ===
'l8.stop() set a flag for the task, asking it to stop gently.'

See also [[ApiReference#wiki-l8cancel|l8.cancel]]() for a more brutal way to stop a task.

=== l8.success() ===
'l8.success( fn )'

task.success() specifies a function to be called when the task terminates.
The function receives a paremeter, l8.result, the last result.
The function is called only if the task is a success. It is called before
the function specified using l8.final()

=== l8.task() ===
'Queue a step in the task's step queue.'


Usage:
```javascript

  l8.task( function(){
    l8.step( function(){
      console.log( "first step" );
      return ["hello", "world"];
    }).step( function( h, w ){
      console.log( h, w )
    })
  })
```

The output, ie result, of a step is the input, ie parameters, of the next
one. Steps can block, using l8.pause() && l8.resume().

When the output of a step is a promise, the step is blocked until the
promise is resolved. The promise's value becomes the new value for the
output of the step.

l8.task(), l8.fork() and l8.repeat() queue "special" steps in the current
task.

The new step is inserted in the task step queue. It is inserted after the
current step for that task. If multiple steps are inserted, they are
inserted in FIFO order, ie the last inserted step will be executed last.

Note: l8.step(...) inserts a step in the "current" task, not the l8 task.
The l8 task is the root task, it is the ultimate "parent" task of all tasks.
The returned value of the .step() function is the actual task whose queue
was augmented.

Queue a step that calls a task.

Usage:
```javascript

  l8.task( function(){
    fs.readFile( "xx.txt", "utf8", l8.flow );
    this.step( function( c ){ return c.toLowerCase() }
  }).then( function( r ){ console.log( "lower cased xx.txt: ", r ) })
```

a_task.task() adds a step that will start a new task with some initial step
to execute. The step is blocked until the sub task is done.

If there is no current task, ie if the current task is the l8 root task,
the new task is created immediatly and it is the return value of the
function. If there is a current task, the returned value is that task 
object. The new task object is created just before the task starts executing
it's first step.

Usage:
```javascript
  var new_task = null
  l8.task( function(){
    task = this;
    ...
  })
```

See also [[ApiReference#wiki-l8fork|l8.fork]]() and [[ApiReference#wiki-l8spawn|l8.spawn]]().

l8#spawn()
Queue a step that will start a "detached" sub task.
Contrary to tasks created using l8.task() and l8.fork() (or using a task
constructor created using l8.Task()), "detached" tasks don't block their
parent task.

See also [[ApiReference#wiki-l8task|l8.task]]()

=== l8.tick() ===
'l8.tick( fn ) is a low level function that schedules the execution of a'

function by the javascript event loop. It is the equivalent to setTimeout()
with a 0 delay.

=== l8.trace() ===
'User can redefine what logger l8.trace() uses, see l8.logger().'


Change the way l8.trace() outputs messages.

Usage:
```javascript

  var save = l8.logger()
   l8.logger( function(){ return function(){
     console.log.apply( console, arguments )
   })
```

Parameter "get_logger" is a function returning a logger, ie a
function called to log messages, like console.log(). l8.trace() will use it.
To restore it to its default value, use l8.logger( null ).
To read the current value, use l8.logger()
Usage: l8.logger( function(){ return console.log } }
Note: because "get_logger" is a function that returns the logger function,
ie because of this added level of indirection, user can fine tune logging
using information available in the context of the application when the
logger function is necessary, versus the information available when the
logger is installed.

=== l8.try_yield() ===
'Alias for l8.try_yield()'


=== l8.var() ===
'Create a "task local" variable.'


Usage:
```javascript

 l8.var( "session", session );
```

The variable is visible by the current task's sub tasks.
See also [[ApiReference#wiki-l8get|l8.get]]() and [[ApiReference#wiki-l8set|l8.set]]().

Note: when a task is done, it's bindings are erased. As a consequence, any
pending spawn task gets inherited by the done task's parent task and cannot
access the erased bindings they previously accessed, resulting in access
attemtps returning typically "undefined" instead of the expected value. To
avoid such a situation, when spawn tasks access shared variables from their
parent, please make sure that the parent task does not terminate until all
spawn tasks are done first. See also [[ApiReference#wiki-l8join|l8.join]]().

Note: please use l8.global() to create variables in the root binding because
l8.var() will actually create a variable in the current task when applied
on the root l8 task.

l8#global()
Create a global "task local variable" that all tasks share.
See also [[ApiReference#wiki-l8var|l8.var]]()

l8#set()
Assign a new value to a task local variable.
Change the value of an existing task local variable or create a new
variable as l8.var() would do.
See also [[ApiReference#wiki-l8get|l8.get]]()

=== l8.wait() ===
'Make a new semaphore.'

See http://en.wikipedia.org/wiki/Semaphore_(programming)
P is .signal() or .release().
V is l8.wait( a_semaphore ) or a_semaphore.then(...)

