{"ts":1351140228955,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// l8.js\r\n//   Task manager\r\n//   https://github.com/JeanHuguesRobert/l8\r\n//\r\n// 2012/10/24, JHR, create\r\n\r\nvar L8 = null\r\n\r\nfunction Task( parent ){\r\n  this.isRoot = false\r\n  this.parent = parent\r\n  this.tasks  = []\r\n  this.beginStack = []\r\n  this.firstStep = null\r\n  this.lastStep  = null\r\n}\r\nTask.prototype = Task\r\n\r\nL8 = new Task( null )\r\nL8.isRoot = true\r\n\r\nCurrentStep = null\r\n\r\nfunction Step( task, parent, previous, block ){\r\n  this.task   = task\r\n  this.parent = parent\r\n  this.block  = block\r\n  if( !previous ){\r\n    this.previous  = null\r\n    this.next      = null\r\n    task.firstStep = task.lastStep = this\r\n  }else if( !previous.next ){\r\n    this.previous  = previous\r\n    this.previous.next = this\r\n    this.next     = null\r\n    task.lastStep = this\r\n  }else{\r\n    this.previous = previous\r\n    this.next     = previous.next\r\n    this.previous.next = this\r\n  }\r\n}\r\nStep.prototype = Step\r\n\r\nTask.__defineGetter__( \"begin\", function(){\r\n  CurrentStep.task.beginStack.push( CurrentStep)\r\n  return this\r\n})\r\n\r\n\r\n\r\n  l8.begin              -- enter new L8 scope\r\n    .step( block )      -- queue a new step on the path to task's completion\r\n    .fork( block )      -- queue a new step on a new parallel path\r\n    .walk( block )      -- walk a step on its path, at most once per step\r\n    .loop               -- enter a non blocking loop, made of iterative steps\r\n    .each               -- enter next iteration step in a non blocking loop\r\n    .repeat( block )    -- queue a blocking loop step\r\n    ._continue          -- like \"continue\", for blocking loops\r\n    ._break             -- \"break\" for blocking loops and forked steps\r\n    ._return( [val] )   -- like \"return\" in normal flow\r\n    .raise( error )     -- raise an error in task\r\n    .spawn( blk [, q] ) -- start a new sub task, maybe paused\r\n    .then( ... )        -- Promise/A protocol, tasks are promises\r\n    .success( block )   -- block to run when task is done without error\r\n    .error( block )     -- block to run when task is done but with error\r\n    .progress( block )  -- block to run when some task is done or step walked\r\n    .final( block )     -- block to run when task is all done\r\n    .l8                 -- return global L8 object\r\n    .task               -- return current task\r\n    .parent             -- return parent task\r\n    .tasks              -- return sub tasks\r\n    .top                -- return top task of sub task\r\n    .state              -- return state of task, I->[Q|R]*->C/E/D\r\n    .pause              -- queue step, waiting until task is resumed\r\n    .waiting            -- true if task waiting while running (ie is queued)\r\n    .resume             -- resume execution of a task waiting at some step\r\n    .yield( value )     -- like \"pause\" but provides a value and returns one\r\n    .run( value )       -- like \"resume\" but provides a value and returns one\r\n    .running            -- true if task not done nor waiting\r\n    .cancel             -- cancel task & its sub tasks, brutal\r\n    .canceled           -- true if task was canceled\r\n    .stop               -- gentle cancel\r\n    .stopping           -- true after a gentle cancel, until task is done\r\n    .stopped            -- true if task was gently canceled (gracefull)\r\n    .done               -- true if task done, else it either waits or runs\r\n    .succeed            -- true if task done without error\r\n    .fail               -- true if task done but with an error\r\n    .err                -- return last raised error\r\n    .result             -- \"return\" value of task, see _return and yield()\r\n    .timeout( milli )   -- cancel task if not done in time\r\n    .sleep( milli )     -- block for a while, then reschedule task\r\n    .wait( lock )       -- queue step until some lock opens, then retry\r\n    .end                -- leave scope or loop\r\n    .scope( function )  -- return the L8 scope guarded version of a function"]],"start1":0,"start2":0,"length1":0,"length2":3886}]],"length":3886}
{"contributors":[],"silentsave":false,"ts":1351140227455,"patch":[[{"diffs":[[1,"// l8.js\r\n//   Task manager\r\n//   https://github.com/JeanHuguesRobert/l8\r\n//\r\n// 2012/10/24, JHR, create\r\n\r\nvar L8 = null\r\n\r\nfunction Task( parent ){\r\n  this.isRoot = false\r\n  this.parent = parent\r\n  this.tasks  = []\r\n  this.beginStack = []\r\n  this.firstStep = null\r\n  this.lastStep  = null\r\n}\r\nTask.prototype = Task\r\n\r\nL8 = new Task( null )\r\nL8.isRoot = true\r\n\r\nCurrentStep = null\r\n\r\nfunction Step( task, parent, previous, block ){\r\n  this.task   = task\r\n  this.parent = parent\r\n  this.block  = block\r\n  if( !previous ){\r\n    this.previous  = null\r\n    this.next      = null\r\n    task.firstStep = task.lastStep = this\r\n  }else if( !previous.next ){\r\n    this.previous  = previous\r\n    this.previous.next = this\r\n    this.next     = null\r\n    task.lastStep = this\r\n  }else{\r\n    this.previous = previous\r\n    this.next     = previous.next\r\n    this.previous.next = this\r\n  }\r\n}\r\nStep.prototype = Step\r\n\r\nTask.__defineGetter__( \"begin\", function(){\r\n  CurrentStep.task.beginStack.push( CurrentStep)\r\n  return this\r\n})\r\n\r\n\r\n\r\n  l8.begin              -- enter new L8 scope\r\n    .step( block )      -- queue a new step on the path to task's completion\r\n    .fork( block )      -- queue a new step on a new parallel path\r\n    .walk( block )      -- walk a step on its path, at most once per step\r\n    .loop               -- enter a non blocking loop, made of iterative steps\r\n    .each               -- enter next iteration step in a non blocking loop\r\n    .repeat( block )    -- queue a blocking loop step\r\n    ._continue          -- like \"continue\", for blocking loops\r\n    ._break             -- \"break\" for blocking loops and forked steps\r\n    ._return( [val] )   -- like \"return\" in normal flow\r\n    .raise( error )     -- raise an error in task\r\n    .spawn( blk [, q] ) -- start a new sub task, maybe paused\r\n    .then( ... )        -- Promise/A protocol, tasks are promises\r\n    .success( block )   -- block to run when task is done without error\r\n    .error( block )     -- block to run when task is done but with error\r\n    .progress( block )  -- block to run when some task is done or step walked\r\n    .final( block )     -- block to run when task is all done\r\n    .l8                 -- return global L8 object\r\n    .task               -- return current task\r\n    .parent             -- return parent task\r\n    .tasks              -- return sub tasks\r\n    .top                -- return top task of sub task\r\n    .state              -- return state of task, I->[Q|R]*->C/E/D\r\n    .pause              -- queue step, waiting until task is resumed\r\n    .waiting            -- true if task waiting while running (ie is queued)\r\n    .resume             -- resume execution of a task waiting at some step\r\n    .yield( value )     -- like \"pause\" but provides a value and returns one\r\n    .run( value )       -- like \"resume\" but provides a value and returns one\r\n    .running            -- true if task not done nor waiting\r\n    .cancel             -- cancel task & its sub tasks, brutal\r\n    .canceled           -- true if task was canceled\r\n    .stop               -- gentle cancel\r\n    .stopping           -- true after a gentle cancel, until task is done\r\n    .stopped            -- true if task was gently canceled (gracefull)\r\n    .done               -- true if task done, else it either waits or runs\r\n    .succeed            -- true if task done without error\r\n    .fail               -- true if task done but with an error\r\n    .err                -- return last raised error\r\n    .result             -- \"return\" value of task, see _return and yield()\r\n    .timeout( milli )   -- cancel task if not done in time\r\n    .sleep( milli )     -- block for a while, then reschedule task\r\n    .wait( lock )       -- queue step until some lock opens, then retry\r\n    .end                -- leave scope or loop\r\n    .scope( function )  -- return the L8 scope guarded version of a function"]],"start1":0,"start2":0,"length1":0,"length2":3886}]],"length":3886,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351140636840,"patch":[[{"diffs":[[0,"ush( CurrentStep"],[1," "],[0,")\r\n"],[-1,""],[0,"  return this\r\n}"]],"start1":980,"start2":980,"length1":35,"length2":36},{"diffs":[[0,"\r\n\r\n"],[-1,"\r\n\r\n  l8.begin              -- enter new L8 scope\r\n    .step( block )      -- queue a new step on the path to task's completion\r\n    .fork( block )      -- queue a new step on a new parallel path\r\n    .walk( block )      -- walk a step on its path, at most once per step\r\n    .loop               -- enter a non blocking loop, made of iterative steps\r\n    .each               -- enter next iteration step in a non blocking loop\r\n    .repeat( block )    -- queue a blocking loop step\r\n    ._continue          -- like \"continue\", for blocking loops\r\n    ._break             -- \"break\" for blocking loops and forked steps\r\n    ._return( [val] )   -- like \"return\" in normal flow\r\n    .raise( error )     -- raise an error in task\r\n    .spawn( blk [, q] ) -- start a new sub task, maybe paused\r\n    .then( ... )        -- Promise/A protocol, tasks are promises\r\n    .success( block )   -- block to run when task is done without error\r\n    .error( block )     -- block to run when task is done but with error\r\n    .progress( block )  -- block to run when some task is done or step walked\r\n    .final( block )     -- block to run when task is all done\r\n    .l8                 -- return global L8 object\r\n    .task               -- return current task\r\n    .parent             -- return parent task\r\n    .tasks              -- return sub tasks\r\n    .top                -- return top task of sub task\r\n    .state              -- return state of task, I->[Q|R]*->C/E/D\r\n    .pause              -- queue step, waiting until task is resumed\r\n    .waiting            -- true if task waiting while running (ie is queued)\r\n    .resume             -- resume execution of a task waiting at some step\r\n    .yield( value )     -- like \"pause\" but provides a value and returns one\r\n    .run( value )       -- like \"resume\" but provides a value and returns one\r\n    .running            -- true if task not done nor waiting\r\n    .cancel             -- cancel task & its sub tasks, brutal\r\n    .canceled           -- true if task was canceled\r\n    .stop               -- gentle cancel\r\n    .stopping           -- true after a gentle cancel, until task is done\r\n    .stopped            -- true if task was gently canceled (gracefull)\r\n    .done               -- true if task done, else it either waits or runs\r\n    .succeed            -- true if task done without error\r\n    .fail               -- true if task done but with an error\r\n    .err                -- return last raised error\r\n    .result             -- \"return\" value of task, see _return and yield()\r\n    .timeout( milli )   -- cancel task if not done in time\r\n    .sleep( milli )     -- block for a while, then reschedule task\r\n    .wait( lock )       -- queue step until some lock opens, then retry\r\n    .end                -- leave scope or loop\r\n    .scope( function )  -- return the L8 scope guarded version of a function// l8.js\r\n//   Task manager\r\n//   https://github.com/JeanHuguesRobert/l8\r\n//\r\n// 2012/10/24, JHR, create\r\n\r\nvar L8 = null\r\n\r\nfunction Task( parent ){\r\n  this.isRoot = false\r\n  this.parent = parent\r\n  this.tasks  = []\r\n  this.beginStack = []\r\n  this.firstStep = null\r\n  this.lastStep  = null\r\n}\r\nTask.prototype = Task\r\n\r\nL8 = new Task( null )\r\nL8.isRoot = true\r\n\r\nCurrentStep = null\r\n\r\nfunction Step( task, parent, previous, block ){\r\n  this.task   = task\r\n  this.parent = parent\r\n  this.block  = block\r\n  if( !previous ){\r\n    this.previous  = null\r\n    this.next      = null\r\n    task.firstStep = task.lastStep = this\r\n  }else if( !previous.next ){\r\n    this.previous  = previous\r\n    this.previous.next = this\r\n    this.next     = null\r\n    task.lastStep = this\r\n  }else{\r\n    this.previous = previous\r\n    this.next     = previous.next\r\n    this.previous.next = this\r\n  }\r\n}\r\nStep.prototype = Step\r\n\r\nTask.__defineGetter__( \"begin\", function(){\r\n  CurrentStep.task.beginStack.push( CurrentStep"],[1,"Task.step = function step( block ){\r\n  if( this.isRoot )return CurrentStep.task.step( block )\r\n  var step = new Step( this, CurrentStep.parent, this.lastStep, block"],[0,")\r\n "]],"start1":1017,"start2":1017,"length1":3870,"length2":172},{"diffs":[[0,"eturn this\r\n"],[1,""],[0,"}"],[-1,")"],[0,"\r\n\r\n\r\n\r\n  l8"]],"start1":1191,"start2":1191,"length1":26,"length2":25}]],"length":4074,"saved":false}
{"ts":1351141213032,"patch":[[{"diffs":[[0,".isRoot "],[1,"    "],[0,"= false\r"]],"start1":157,"start2":157,"length1":16,"length2":20},{"diffs":[[0,"e\r\n  this.parent"],[1,"Task"],[0," = parent\r\n  thi"]],"start1":175,"start2":175,"length1":32,"length2":36},{"diffs":[[0,"\r\n  "],[-1,"this.tasks"],[1,"if( parent ){\r\n    this.parentTask.subTasks.push( this)\r\n  }\r\n  this.subTasks "],[0,"  = "]],"start1":204,"start2":204,"length1":18,"length2":86},{"diffs":[[0,"s.firstStep "],[1," "],[0,"= null\r\n  th"]],"start1":323,"start2":323,"length1":24,"length2":25},{"diffs":[[0," this.lastStep  "],[1," "],[0,"= null\r\n}\r\nTask."]],"start1":345,"start2":345,"length1":32,"length2":33},{"diffs":[[0,"sk( null"],[-1," "],[0,""],[1,""],[0,")\r\nL8.is"]],"start1":409,"start2":409,"length1":17,"length2":16},{"diffs":[[0,"rentStep"],[-1," "],[0,")\r\n"],[1,""],[0,"  return"]],"start1":1065,"start2":1065,"length1":20,"length2":19},{"diffs":[[0,"p( block"],[-1," "],[0,")\r\n  var"]],"start1":1180,"start2":1180,"length1":17,"length2":16},{"diffs":[[0,"s\r\n}\r\n\r\n"],[1,"Task.fork = function fork( block ){\r\n  if( this.isRoot )return CurrentStep.task.fork( block)\r\n  var task = new Task( this.task)\r\n  return this\r\n}\r\n\r\n"],[0,"\r\n\r\n  l8"]],"start1":1275,"start2":1275,"length1":16,"length2":165}]],"length":4298,"saved":false}
{"ts":1351141366545,"patch":[[{"diffs":[[0,"this.task)\r\n"],[1,"  var step = new Step( task, CurrentStep, null, block)\r\n"],[0,"  return thi"]],"start1":1400,"start2":1400,"length1":24,"length2":80}]],"length":4354,"saved":false}
{"ts":1351142761506,"patch":[[{"diffs":[[0,"Tasks   "],[1," "],[0,"= []\r\n  "]],"start1":280,"start2":280,"length1":16,"length2":17},{"diffs":[[0,"inStack "],[1," "],[0,"= []\r\n  "]],"start1":305,"start2":305,"length1":16,"length2":17},{"diffs":[[0,"stStep  "],[1," "],[0,"= null\r\n"]],"start1":330,"start2":330,"length1":16,"length2":17},{"diffs":[[0,"tStep   "],[1," "],[0,"= null\r\n"],[1,"  this.currentStep = null\r\n  this.wasCanceled = false\r\n"],[0,"}\r\nTask."]],"start1":357,"start2":357,"length1":24,"length2":80},{"diffs":[[0," = true\r"],[1,"\nL8.stepQueue = []\r"],[0,"\n\r\nCurre"]],"start1":488,"start2":488,"length1":16,"length2":35},{"diffs":[[0,"tStep = null\r\n\r\n"],[1,"L8.scheduler = function scheduler(){\r\n  var step\r\n  while( step = this.stepQueue.shift() ){\r\n    step.scheduler()\r\n  }\r\n}\r\n\r\n"],[0,"function Step( t"]],"start1":524,"start2":524,"length1":32,"length2":157},{"diffs":[[0," task.lastStep ="],[1," task.currentStep ="],[0," this\r\n  }else i"]],"start1":877,"start2":877,"length1":32,"length2":51},{"diffs":[[0,"e = Step\r\n\r\n"],[1,"Step.scheduler = function step_scheduler(){\r\n\r\n}\r\n\r\n"],[0,"Task.__defin"]],"start1":1191,"start2":1191,"length1":24,"length2":76},{"diffs":[[0,", null, block)\r\n"],[-1,""],[0,"  return this\r\n}"]],"start1":1726,"start2":1726,"length1":32,"length2":32},{"diffs":[[0,"s\r\n}\r\n\r\n"],[1,"Task.walk = function walk( block ){\r\n  var step = CurrentStep\r\n  return function walk_cb(){\r\n     CurrentStep = step\r\n     block.apply( step.task, arguments)\r\n\r\n  }\r\n}\r\n\r\n"],[0,"\r\n\r\n  l8"]],"start1":1754,"start2":1754,"length1":16,"length2":187}]],"length":4799,"saved":false}
{"ts":1351143081860,"patch":[[{"diffs":[[0," false\r\n"],[1,"  this.isScheduled = false\r\n"],[0,"}\r\nTask."]],"start1":421,"start2":421,"length1":16,"length2":44},{"diffs":[[0,"ler(){\r\n"],[1,"  if( !this.isScheduled )return\r\n  try{\r\n    this.block()\r\n  }catch( e ){\r\n    throw e\r\n  }"],[0,"\r\n}\r\n\r\nT"]],"start1":1268,"start2":1268,"length1":16,"length2":107}]],"length":4918,"saved":false}
{"ts":1351143432702,"patch":[[{"diffs":[[0,"s.is"],[-1,"Scheduled = fals"],[1,"Running   = tru"],[0,"e\r\n}"]],"start1":434,"start2":434,"length1":24,"length2":23},{"diffs":[[0,"s.is"],[-1,"Scheduled )return"],[1,"Running )return\r\n  var step = CurrentStep\r\n  CurrentStep = this"],[0,"\r\n  "]],"start1":1285,"start2":1285,"length1":25,"length2":71},{"diffs":[[0,"hrow e\r\n"],[1,"  }finally{\r\n    CurrentStep = step\r\n"],[0,"  }\r\n}\r\n"]],"start1":1401,"start2":1401,"length1":16,"length2":53}]],"length":5000,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351169332003,"patch":[[{"diffs":[[1,"// l8.js\r\n//   Task manager\r\n//   https://github.com/JeanHuguesRobert/l8\r\n//\r\n// 2012/10/24, JHR, create\r\n\r\nvar L8 = null\r\nvar l8 = null\r\n\r\nvar Util = require( \"util\")\r\n\r\nfunction trace(){\r\n  var buf = [\"L8\"]\r\n  for( var item in arguments ){ buf.push( item)}\r\n  Util.puts( buf.join( \",\"))\r\n}\r\n\r\nfunction Task( parent ){\r\n  this.isRoot     = false\r\n  this.parentTask = parent\r\n  if( parent ){\r\n    this.parentTask.subTasks.push( this)\r\n  }\r\n  this.subTasks    = []\r\n  this.beginStack  = []\r\n  this.firstStep   = null\r\n  this.lastStep    = null\r\n  this.currentStep = null\r\n  this.wasCanceled = false\r\n  this.isRunning   = true\r\n}\r\nTask.prototype = Task\r\n\r\nL8 = l8 = new Task( null)\r\nL8.isRoot = true\r\nL8.stepQueue = []\r\nL8.isScheduled = false\r\n\r\nvar CurrentStep = null\r\n\r\nL8.scheduler = function scheduler(){\r\n  if( !L8.isScheduled ){\r\n    L8.isScheduled = true\r\n    process.nextTick( tick)\r\n    return L8\r\n  }\r\n  function tick(){\r\n    L8.isScheduled = false\r\n    var step\r\n    while( step = L8.stepQueue.shift() ){\r\n      step.scheduler()\r\n    }\r\n    L8.scheduler()\r\n  }\r\n}\r\n\r\nL8.enqueueStep = function( step ){\r\n  if( step.wasQueued )return\r\n  L8.stepQueue.push( step)\r\n  step.wasQueued = true\r\n  step.isRunning = true\r\n}\r\n\r\nfunction Step( task, parent, previous, block ){\r\n  this.task   = task\r\n  this.parent = parent\r\n  this.block  = block\r\n  if( !previous ){\r\n    this.previous  = null\r\n    this.next      = null\r\n    task.firstStep = task.lastStep = task.currentStep = this\r\n  }else if( !previous.next ){\r\n    this.previous  = previous\r\n    this.previous.next = this\r\n    this.next     = null\r\n    task.lastStep = this\r\n  }else{\r\n    this.previous = previous\r\n    this.next     = previous.next\r\n    this.previous.next = this\r\n  }\r\n  this.wasQueued = false\r\n  this.isRunning = false\r\n}\r\nStep.prototype = Step\r\n\r\nStep.scheduler = function step_scheduler(){\r\n  if( !this.wasQueued )return\r\n  this.wasQueued = false\r\n  if( !this.isRunning )return\r\n  var step = CurrentStep\r\n  CurrentStep = this\r\n  try{\r\n    this.block()\r\n  }catch( e ){\r\n    throw e\r\n  }finally{\r\n    CurrentStep = step\r\n    L8.scheduler()\r\n  }\r\n}\r\n\r\nTask.__defineGetter__( \"begin\", function(){\r\n  CurrentStep.task.beginStack.push( CurrentStep)\r\n  return this\r\n})\r\n\r\nTask.__defineGetter__( \"end\", function(){\r\n  var step  = CurrentStep\r\n  var task  = step.task\r\n  var stack = task.beginStack\r\n  var top   = stack[stack.length - 1]\r\n  if( top != step ){\r\n    throw \"Unbalanced L8.end\"\r\n  }\r\n  stack.pop()\r\n  return this\r\n}\r\n\r\nTask.step = function step( block ){\r\n  if( this.isRoot )return CurrentStep.task.step( block)\r\n  var step = new Step( this, CurrentStep.parent, this.lastStep, block)\r\n  return this\r\n}\r\n\r\nTask.fork = function fork( block ){\r\n  if( this.isRoot )return CurrentStep.task.fork( block)\r\n  var task = new Task( this.task)\r\n  var step = new Step( task, CurrentStep, null, block)\r\n  return this\r\n}\r\n\r\nTask.walk = function walk( block ){\r\n  var step = CurrentStep\r\n  return function walk_cb(){\r\n    var previous_step = CurrentStep\r\n    CurrentStep = step\r\n    try{\r\n      block.apply( step.task, arguments)\r\n    }catch( e ){\r\n      throw e\r\n    }finally{\r\n      CurrentStep = previous_step\r\n      if( step.isRunning ){\r\n        step.isRunning = false\r\n        var next_step = step.next\r\n        if( next_step ){\r\n          L8.enqueueStep( next_step)\r\n        }\r\n      }\r\n      L8.scheduler()\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n\r\n  l8.begin              -- enter new L8 scope\r\n    .step( block )      -- queue a new step on the path to task's completion\r\n    .fork( block )      -- queue a new step on a new parallel path\r\n    .walk( block )      -- walk a step on its path, at most once per step\r\n    .loop               -- enter a non blocking loop, made of iterative steps\r\n    .each               -- enter next iteration step in a non blocking loop\r\n    .repeat( block )    -- queue a blocking loop step\r\n    ._continue          -- like \"continue\", for blocking loops\r\n    ._break             -- \"break\" for blocking loops and forked steps\r\n    ._return( [val] )   -- like \"return\" in normal flow\r\n    .raise( error )     -- raise an error in task\r\n    .spawn( blk [, q] ) -- start a new sub task, maybe paused\r\n    .then( ... )        -- Promise/A protocol, tasks are promises\r\n    .success( block )   -- block to run when task is done without error\r\n    .error( block )     -- block to run when task is done but with error\r\n    .progress( block )  -- block to run when some task is done or step walked\r\n    .final( block )     -- block to run when task is all done\r\n    .l8                 -- return global L8 object\r\n    .task               -- return current task\r\n    .parent             -- return parent task\r\n    .tasks              -- return sub tasks\r\n    .top                -- return top task of sub task\r\n    .state              -- return state of task, I->[Q|R]*->C/E/D\r\n    .pause              -- queue step, waiting until task is resumed\r\n    .waiting            -- true if task waiting while running (ie is queued)\r\n    .resume             -- resume execution of a task waiting at some step\r\n    .yield( value )     -- like \"pause\" but provides a value and returns one\r\n    .run( value )       -- like \"resume\" but provides a value and returns one\r\n    .running            -- true if task not done nor waiting\r\n    .cancel             -- cancel task & its sub tasks, brutal\r\n    .canceled           -- true if task was canceled\r\n    .stop               -- gentle cancel\r\n    .stopping           -- true after a gentle cancel, until task is done\r\n    .stopped            -- true if task was gently canceled (gracefull)\r\n    .done               -- true if task done, else it either waits or runs\r\n    .succeed            -- true if task done without error\r\n    .fail               -- true if task done but with an error\r\n    .err                -- return last raised error\r\n    .result             -- \"return\" value of task, see _return and yield()\r\n    .timeout( milli )   -- cancel task if not done in time\r\n    .sleep( milli )     -- block for a while, then reschedule task\r\n    .wait( lock )       -- queue step until some lock opens, then retry\r\n    .end                -- leave scope or loop\r\n    .scope( function )  -- return the L8 scope guarded version of a function\r\n\r\n    */\r\n\r\nfunction test_1(){\r\n  function t(){\r\n    var buf = [\"test_1\"]\r\n    for( item in argument ){buf.push( item)}\r\n    trace.apply( this, buf)\r\n  }\r\n  function task(){\r\n    l8.begin\r\n    .step( function(){ t( \"starts\")})\r\n    .step( function(){ t( \"step\")})\r\n    .end\r\n  }\r\n  L8.scheduler()\r\n}\r\n\r\ntrace( \"starting L8\")\r\nvar count_down = 5\r\nsetInterval(\r\n  function(){\r\n    trace( \"tick \" + count_down--)\r\n    if( !count_down){\r\n      process.exit( 0)\r\n    }\r\n  }\r\n  1000\r\n)\r\ntrace( \"done L8\")\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6761}]],"length":6761,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351169424099,"patch":[[{"diffs":[[0,"  return this\r\n}"],[1,")"],[0,"\r\n\r\nTask.step = "]],"start1":2472,"start2":2472,"length1":32,"length2":33}]],"length":6762,"saved":false}
{"ts":1351169460375,"patch":[[{"diffs":[[0,"    for("],[1," var"],[0," item in"]],"start1":6337,"start2":6337,"length1":16,"length2":20},{"diffs":[[0,"\r\n    }\r\n  }"],[1,","],[0,"\r\n  1000\r\n)\r"]],"start1":6722,"start2":6722,"length1":24,"length2":25}]],"length":6767,"saved":false}
{"ts":1351169754481,"patch":[[{"diffs":[[0,"ar i"],[-1,"tem in arguments ){ buf.push( item"],[1,"i = 0 ; ii < argumets.length ; ii++){ buf.push( arguments[ii]"],[0,")}\r\n"]],"start1":218,"start2":218,"length1":42,"length2":69}]],"length":6794,"saved":false}
{"ts":1351169774254,"patch":[[{"diffs":[[0,"< argume"],[1,"n"],[0,"ts.lengt"]],"start1":233,"start2":233,"length1":16,"length2":17}]],"length":6795,"saved":false}
{"ts":1351169832561,"patch":[[{"diffs":[[0,"join( \","],[1," "],[0,"\"))\r\n}\r\n"]],"start1":305,"start2":305,"length1":16,"length2":17},{"diffs":[[0,"ick \" + "],[1,"--"],[0,"count_do"]],"start1":6683,"start2":6683,"length1":16,"length2":18},{"diffs":[[0,"unt_down"],[-1,"--"],[0,")\r\n    i"]],"start1":6695,"start2":6695,"length1":18,"length2":16}]],"length":6796,"saved":false}
{"ts":1351170410929,"patch":[[{"diffs":[[0,"Step\r\n\r\n"],[1,"CurrentStep = new Step( L8, null, null, null)\r\n\r\n"],[0,"Step.sch"]],"start1":1836,"start2":1836,"length1":16,"length2":65},{"diffs":[[0,"\r\n    */\r\n\r\n"],[1,"L8.startup = function(){\r\n\r\n}\r\n\r\n"],[0,"function tes"]],"start1":6340,"start2":6340,"length1":24,"length2":57},{"diffs":[[0,"ar i"],[-1,"tem in argument ){"],[1,"i = 0 ; ii < arguments.length ; ii++ ) "],[0,"buf."]],"start1":6458,"start2":6458,"length1":26,"length2":47},{"diffs":[[0,"sh( "],[-1,"item)}"],[1,"arguments[ii])"],[0,"\r\n  "]],"start1":6507,"start2":6507,"length1":14,"length2":22},{"diffs":[[0,", buf)\r\n"],[-1,""],[0,"  }\r\n"],[1,"  t( \"starts\")\r\n"],[0,"  functi"]],"start1":6548,"start2":6548,"length1":21,"length2":37},{"diffs":[[0,"000\r\n)\r\n"],[1,"test_1\r\n"],[0,"trace( \""]],"start1":6896,"start2":6896,"length1":16,"length2":24}]],"length":6931,"saved":false}
{"ts":1351170509288,"patch":[[{"diffs":[[0,"\r\ntest_1"],[1,"()"],[0,"\r\ntrace("]],"start1":6902,"start2":6902,"length1":16,"length2":18}]],"length":6933,"saved":false}
{"ts":1351170555992,"patch":[[{"diffs":[[0,".begin\r\n    "],[1,"  "],[0,".step( funct"]],"start1":6603,"start2":6603,"length1":24,"length2":26},{"diffs":[[0,"starts\")})\r\n"],[1,"  "],[0,"    .step( f"]],"start1":6640,"start2":6640,"length1":24,"length2":26},{"diffs":[[0,"d\r\n  }\r\n"],[1,"  task()\r\n"],[0,"  L8.sch"]],"start1":6698,"start2":6698,"length1":16,"length2":26}]],"length":6947,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351170786635,"patch":[[{"diffs":[[0,"on task(){\r\n"],[1,"    t( \"task\")\r\n"],[0,"    l8.begin"]],"start1":6585,"start2":6585,"length1":24,"length2":40},{"diffs":[[0,".begin\r\n"],[-1,""],[0,"      .s"]],"start1":6619,"start2":6619,"length1":16,"length2":16},{"diffs":[[0,"task()\r\n"],[1,"  t( \"starts scheduler\")\r\n"],[0,"  L8.sch"]],"start1":6724,"start2":6724,"length1":16,"length2":42},{"diffs":[[0,"\")\r\n"],[-1,"// l8.js\r\n//   Task manager\r\n//   https://github.com/JeanHuguesRobert/l8\r\n//\r\n// 2012/10/24, JHR, create\r\n\r\nvar L8 = null\r\n\r\nfunction Task( parent ){\r\n  this.isRoot     = false\r\n  this.parentTask = parent\r\n  if( parent ){\r\n    this.parentTask.subTasks.push( this)\r\n  }\r\n  this.subTasks    = []\r\n  this.beginStack  = []\r\n  this.firstStep   = null\r\n  this.lastStep    = null\r\n  this.currentStep = null\r\n  this.wasCanceled = false\r\n  this.isRunning   = true\r\n}\r\nTask.prototype = Task\r\n\r\nL8 = new Task( null)\r\nL8.isRoot = true\r\nL8.stepQueue = []\r\n\r\nCurrentStep = null\r\n\r\nL8.scheduler = function scheduler(){\r\n  var step\r\n  while( step = this.stepQueue.shift() ){\r\n    step.scheduler()\r\n  }\r\n}\r\n\r\nfunction Step( task, parent, previous, block ){\r\n  this.task   = task\r\n  this.parent = parent\r\n  this.block  = block\r\n  if( !previous ){\r\n    this.previous  = null\r\n    this.next      = null\r\n    task.firstStep = task.lastStep = task.currentStep = this\r\n  }else if( !previous.next ){\r\n    this.previous  = previous\r\n    this.previous.next = this\r\n    this.next     = null\r\n    task.lastStep = this\r\n  }else{\r\n    this.previous = previous\r\n    this.next     = previous.next\r\n    this.previous.next = this\r\n  }\r\n}\r\nStep.prototype = Step\r\n\r\nStep.scheduler = function step_scheduler(){\r\n  if( !this.isRunning )return\r\n  var step = CurrentStep\r\n  CurrentStep = this\r\n  try{\r\n    this.block()\r\n  }catch( e ){\r\n    throw e\r\n  }finally{\r\n    CurrentStep = step\r\n  }\r\n}\r\n\r\nTask.__defineGetter__( \"begin\", function(){\r\n  CurrentStep.task.beginStack.push( CurrentStep)\r\n  return this\r\n})\r\n\r\nTask.step = function step( block ){\r\n  if( this.isRoot )return CurrentStep.task.step( block)\r\n  var step = new Step( this, CurrentStep.parent, this.lastStep, block)\r\n  return this\r\n}\r\n\r\nTask.fork = function fork( block ){\r\n  if( this.isRoot )return CurrentStep.task.fork( block)\r\n  var task = new Task( this.task)\r\n  var step = new Step( task, CurrentStep, null, block)\r\n  return this\r\n}\r\n\r\nTask.walk = function walk( block ){\r\n  var step = CurrentStep\r\n  return function walk_cb(){\r\n     CurrentStep = step\r\n     block.apply( step.task, arguments)\r\n\r\n  }\r\n}\r\n\r\n\r\n\r\n  l8.begin              -- enter new L8 scope\r\n    .step( block )      -- queue a new step on the path to task's completion\r\n    .fork( block )      -- queue a new step on a new parallel path\r\n    .walk( block )      -- walk a step on its path, at most once per step\r\n    .loop               -- enter a non blocking loop, made of iterative steps\r\n    .each               -- enter next iteration step in a non blocking loop\r\n    .repeat( block )    -- queue a blocking loop step\r\n    ._continue          -- like \"continue\", for blocking loops\r\n    ._break             -- \"break\" for blocking loops and forked steps\r\n    ._return( [val] )   -- like \"return\" in normal flow\r\n    .raise( error )     -- raise an error in task\r\n    .spawn( blk [, q] ) -- start a new sub task, maybe paused\r\n    .then( ... )        -- Promise/A protocol, tasks are promises\r\n    .success( block )   -- block to run when task is done without error\r\n    .error( block )     -- block to run when task is done but with error\r\n    .progress( block )  -- block to run when some task is done or step walked\r\n    .final( block )     -- block to run when task is all done\r\n    .l8                 -- return global L8 object\r\n    .task               -- return current task\r\n    .parent             -- return parent task\r\n    .tasks              -- return sub tasks\r\n    .top                -- return top task of sub task\r\n    .state              -- return state of task, I->[Q|R]*->C/E/D\r\n    .pause              -- queue step, waiting until task is resumed\r\n    .waiting            -- true if task waiting while running (ie is queued)\r\n    .resume             -- resume execution of a task waiting at some step\r\n    .yield( value )     -- like \"pause\" but provides a value and returns one\r\n    .run( value )       -- like \"resume\" but provides a value and returns one\r\n    .running            -- true if task not done nor waiting\r\n    .cancel             -- cancel task & its sub tasks, brutal\r\n    .canceled           -- true if task was canceled\r\n    .stop               -- gentle cancel\r\n    .stopping           -- true after a gentle cancel, until task is done\r\n    .stopped            -- true if task was gently canceled (gracefull)\r\n    .done               -- true if task done, else it either waits or runs\r\n    .succeed            -- true if task done without error\r\n    .fail               -- true if task done but with an error\r\n    .err                -- return last raised error\r\n    .result             -- \"return\" value of task, see _return and yield()\r\n    .timeout( milli )   -- cancel task if not done in time\r\n    .sleep( milli )     -- block for a while, then reschedule task\r\n    .wait( lock )       -- queue step until some lock opens, then retry\r\n    .end                -- leave scope or loop\r\n    .scope( function )  -- return the L8 scope guarded version of a function"]],"start1":6985,"start2":6985,"length1":5004,"length2":4}]],"length":6989,"saved":false}
{"ts":1351171056698,"patch":[[{"diffs":[[0,"if( this.isRoot "],[-1,")"],[1,"&& CurrentStep.task != this){\r\n    "],[0,"return CurrentSt"]],"start1":2610,"start2":2610,"length1":33,"length2":67},{"diffs":[[0,"ep( block)\r\n"],[1,"  }\r\n"],[0,"  var step ="]],"start1":2687,"start2":2687,"length1":24,"length2":29}]],"length":7028,"saved":false}
{"ts":1351171102170,"patch":[[{"diffs":[[0,"( \"start"],[-1,"s"],[1," step"],[0,"\")})\r\n  "]],"start1":6692,"start2":6692,"length1":17,"length2":21}]],"length":7032,"saved":false}
{"ts":1351173731989,"patch":[[{"diffs":[[0,".pop()\r\n"],[1,"  if( !stack.length ){\r\n    if( task.firstStep ){\r\n      L8.enqueueStep( task.firstStep)\r\n    }\r\n  }\r\n"],[0,"  return"]],"start1":2542,"start2":2542,"length1":16,"length2":118}]],"length":7134,"saved":false}
{"ts":1351174119353,"patch":[[{"diffs":[[0,"function"],[1," enqueue_step"],[0,"( step )"]],"start1":1122,"start2":1122,"length1":16,"length2":29},{"diffs":[[0,"urrentStep ="],[1," null //"],[0," new Step( L"]],"start1":1858,"start2":1858,"length1":24,"length2":32}]],"length":7155,"saved":false}
{"ts":1351174215786,"patch":[[{"diffs":[[0,"ion(){\r\n"],[1,"  task = CurrentStep ? CurrentStep.task : L8\r\n"],[0,"  Curren"]],"start1":2254,"start2":2254,"length1":16,"length2":62}]],"length":7201,"saved":false}
{"ts":1351174336315,"patch":[[{"diffs":[[0,": L8\r\n  "],[-1,"CurrentStep."],[0,"task.beg"]],"start1":2302,"start2":2302,"length1":28,"length2":16},{"diffs":[[0,"\r\n  var "],[-1,"step"],[1,"task"],[0,"  = Curr"]],"start1":2408,"start2":2408,"length1":20,"length2":20},{"diffs":[[0,"Step"],[-1,"\r\n  var task  = s"],[1," ? CurrentS"],[0,"tep.task"],[1," : L8"],[0,"\r\n  "]],"start1":2431,"start2":2431,"length1":33,"length2":32}]],"length":7188,"saved":false}
{"ts":1351174411714,"patch":[[{"diffs":[[0,"sRoot &&"],[1," CurrentTask &&"],[0," Current"]],"start1":2776,"start2":2776,"length1":16,"length2":31}]],"length":7203,"saved":false}
{"ts":1351174434135,"patch":[[{"diffs":[[0," != this"],[1," "],[0,"){\r\n    "]],"start1":2816,"start2":2816,"length1":16,"length2":17}]],"length":7204,"saved":false}
{"ts":1351174466634,"patch":[[{"diffs":[[0," Current"],[-1,"Task"],[1,"Step"],[0," && Curr"]],"start1":2784,"start2":2784,"length1":20,"length2":20}]],"length":7204,"saved":false}
{"ts":1351174528708,"patch":[[{"diffs":[[0,"ck)\r\n  }\r\n  var "],[1,"parent = CurrentStep ? CurrentStep.parent : null\r\n  var "],[0,"step = new Step("]],"start1":2866,"start2":2866,"length1":32,"length2":88},{"diffs":[[0,"( this, "],[-1,"CurrentStep."],[0,"parent, "]],"start1":2953,"start2":2953,"length1":28,"length2":16}]],"length":7248,"saved":false}
{"ts":1351174672635,"patch":[[{"diffs":[[0,"\r\n  var "],[-1,"task"],[1,"step"],[0,"  = Curr"]],"start1":2408,"start2":2408,"length1":20,"length2":20},{"diffs":[[0," CurrentStep"],[-1," ? CurrentS"],[1,"\r\n  var task  = step ? s"],[0,"tep.task : L"]],"start1":2423,"start2":2423,"length1":35,"length2":48}]],"length":7261,"saved":false}
{"ts":1351175280889,"patch":[[{"diffs":[[0,"= true\r\n"],[1,"  this.errorBlock  = null\r\n  this.finalBlock  = null\r\n"],[0,"}\r\nTask."]],"start1":647,"start2":647,"length1":16,"length2":70},{"diffs":[[0,"lock()\r\n"],[1,"    if( this.isRunning ){\r\n      this.isRunning = false\r\n      if( this.next ){\r\n        L8.enqueueStep( this.next)\r\n      }else{\r\n        var task = this.task\r\n        // ToDo: sub task\r\n        if( task.finalBlock ){\r\n          try{\r\n            task.finalBlock()\r\n          }catch( e ){\r\n            throw e\r\n          }\r\n        }\r\n      }\r\n    }\r\n"],[0,"  }catch"]],"start1":2167,"start2":2167,"length1":16,"length2":368},{"diffs":[[0,"in\r\n      .step("],[1," "],[0," function(){ t( "]],"start1":7297,"start2":7297,"length1":32,"length2":33},{"diffs":[[0,"  .step("],[1," "],[0," functio"]],"start1":7351,"start2":7351,"length1":16,"length2":17},{"diffs":[[0," \"step\")})\r\n"],[1,"      .final( function(){ t( \"final\")})\r\n"],[0,"    .end\r\n  "]],"start1":7375,"start2":7375,"length1":24,"length2":65}]],"length":7710,"saved":false}
{"ts":1351175438717,"patch":[[{"diffs":[[0,"}\r\n}\r\n\r\n"],[1,"Task.final = function final( block ){\r\n  this.finalBlock = block\r\n  return this\r\n}\r\n\r\n"],[0,"/*\r\n\r\n  "]],"start1":4136,"start2":4136,"length1":16,"length2":102}]],"length":7796,"saved":false}
{"ts":1351175738684,"patch":[[{"diffs":[[0," \"step\")})\r\n"],[1,"      .step(  function(){\r\n        t( \"sleep\")\r\n        this.sleep( 100)\r\n        t( \"sleep done\")\r\n      })\r\n"],[0,"      .final"]],"start1":7461,"start2":7461,"length1":24,"length2":134}]],"length":7906,"saved":false}
{"ts":1351175815657,"patch":[[{"diffs":[[0,"( \"sleep"],[-1," done"],[1,"ing"],[0,"\")\r\n    "]],"start1":7556,"start2":7556,"length1":21,"length2":19},{"diffs":[[0,")\r\n     "],[1," "],[-1," "],[1,"})\r\n      .step(  function(){ t( \"sleep done\")"],[0,"})\r\n    "]],"start1":7568,"start2":7568,"length1":17,"length2":63}]],"length":7950,"saved":false}
{"ts":1351176513731,"patch":[[{"diffs":[[0,"\r\n\r\n"],[-1,"Step.scheduler = function step_scheduler(){\r\n  if( !this.wasQueued )return\r\n  this.wasQueued = false\r\n  if( !this.isRunning )return\r\n  var step = CurrentStep\r\n  CurrentStep = this\r\n  try{\r\n    this.block()\r\n    if( this.isRunning ){\r\n      this.isRunning = false\r\n      if( this.next ){\r\n        L8.enqueueStep( this.next)\r\n      }else{\r\n        var task = this.task\r\n        // ToDo: sub task\r\n        if( task.finalBlock ){\r\n          try{\r\n            task.finalBlock()\r\n          }catch( e ){\r\n            throw e\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }catch( e ){\r\n    throw e\r\n  }finally{\r\n    CurrentStep = step\r\n    L8.scheduler()\r\n  }\r\n}\r\n\r\n"],[0,"Task"]],"start1":1964,"start2":1964,"length1":663,"length2":8},{"diffs":[[0,"    "],[-1,"if( step.isRunning ){\r\n        step.isRunning = false\r\n        var next_step = step."],[1,"step.scheduleNext()\r\n      L8.scheduler()\r\n    }\r\n  }\r\n}\r\n\r\nStep.scheduler = function step_scheduler(){\r\n  if( !this.wasQueued )return\r\n  this.wasQueued = false\r\n  if( !this.isRunning )return\r\n  var step = CurrentStep\r\n  CurrentStep = this\r\n  try{\r\n    this.block()\r\n    this.scheduleNext()\r\n  }catch( e ){\r\n    throw e\r\n  }finally{\r\n    CurrentStep = step\r\n    L8.scheduler()\r\n  }\r\n}\r\n\r\nStep.scheduleNext = schedule_"],[0,"next"],[1,"(){"],[0,"\r\n  "],[-1,"      if( next_step ){\r\n          L8.enqueueStep( next_step)\r\n        }\r\n      }\r\n      L8.scheduler()\r\n    }\r\n  }\r\n}\r\n\r\nTask.final = function final( block ){\r\n  this.finalBlock = block\r\n  return this"],[1,"if( !this.isRunning )return\r\n  this.isRunning = false\r\n  var next_step = this.next\r\n  if( next_step ){\r\n    L8.enqueueStep( next_step)\r\n  }else{\r\n    var task = this.task\r\n    // ToDo: sub task\r\n    if( task.finalBlock ){\r\n      try{\r\n        task.finalBlock()\r\n      }catch( e ){\r\n        throw e\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nTask.final = function final( block ){\r\n  this.finalBlock = block\r\n  return this\r\n}\r\n\r\nTask.sleep = function sleep( delay ){\r\n  var that = this\r\n  setTimeout( function() {\r\n    that.scheduleNext()\r\n  }, delay);"],[0,"\r\n}\r"]],"start1":3272,"start2":3272,"length1":300,"length2":970}]],"length":7965,"saved":false}
{"ts":1351176580892,"patch":[[{"diffs":[[0,"leNext ="],[1," function"],[0," schedul"]],"start1":3675,"start2":3675,"length1":16,"length2":25}]],"length":7974,"saved":false}
{"ts":1351176733010,"patch":[[{"diffs":[[0,"  this.block"],[-1,"("],[1,".apply( this.task"],[0,")\r\n    this."]],"start1":3527,"start2":3527,"length1":25,"length2":41}]],"length":7990,"saved":false}
{"ts":1351176897272,"patch":[[{"diffs":[[0,"var "],[-1,"that = this"],[1,"step = CurrentStep"],[0,"\r\n  "]],"start1":4181,"start2":4181,"length1":19,"length2":26},{"diffs":[[0,"    "],[-1,"that"],[1,"step"],[0,".sch"]],"start1":4233,"start2":4233,"length1":12,"length2":12}]],"length":7997,"saved":false}
{"ts":1351176968054,"patch":[[{"diffs":[[0,".sleep( "],[-1,"1"],[1,"20"],[0,"00)\r\n   "]],"start1":7580,"start2":7580,"length1":17,"length2":18}]],"length":7998,"saved":false}
{"ts":1351177007531,"patch":[[{"diffs":[[0,", delay)"],[-1,";"],[1,"\r\n  return this"],[0,"\r\n}\r\n\r\n/"]],"start1":4261,"start2":4261,"length1":17,"length2":31}]],"length":8012,"saved":false}
{"ts":1351177228551,"patch":[[{"diffs":[[0,"\r\n  "],[-1,"setTimeout( function() {"],[1,"var task = step.task\r\n  task.currentStep = step\r\n  setTimeout( function() {\r\n    if( !task.currentStep == step )return\r\n    step.isRunning = true"],[0,"\r\n  "]],"start1":4203,"start2":4203,"length1":32,"length2":153},{"diffs":[[0,"delay)\r\n"],[1,"  step.isRunning = false\r\n"],[0,"  return"]],"start1":4384,"start2":4384,"length1":16,"length2":42}]],"length":8159,"saved":false}
{"ts":1351177348576,"patch":[[{"diffs":[[0,"\r\n  "],[-1,"task.currentStep = step"],[1,"if( !step.isRunning ){\r\n    throw \"Can't sleep, not running\"\r\n  }\r\n  task.currentStep = step\r\n  step.isRunning = false"],[0,"\r\n  "]],"start1":4227,"start2":4227,"length1":31,"length2":126},{"diffs":[[0,"y)\r\n"],[-1,"  step.isRunning = false\r\n"],[0,"  re"]],"start1":4483,"start2":4483,"length1":34,"length2":8}]],"length":8228,"saved":false}
{"ts":1351177376155,"patch":[[{"diffs":[[0,"tStep =="],[1,"="],[0," step )r"]],"start1":4399,"start2":4399,"length1":16,"length2":17}]],"length":8229,"saved":false}
{"ts":1351177405201,"patch":[[{"diffs":[[0,".task !="],[1,"="],[0," this ){"]],"start1":2575,"start2":2575,"length1":16,"length2":17}]],"length":8230,"saved":false}
{"ts":1351177934075,"patch":[[{"diffs":[[0,"\r\n  "],[-1,"return function walk_cb(){\r\n    var previous_step = CurrentStep\r\n    CurrentStep = step\r\n    try{\r\n      block.apply( step.task, arguments)"],[1,"if( !step.isRunning ){\r\n    throw \"Can't walk, not running\"\r\n  }\r\n  step.isRunning = false\r\n  step.task.currentStep = step\r\n  var that = this\r\n  return function walk_cb(){\r\n    var previous_step = CurrentStep\r\n    CurrentStep = step\r\n    try{\r\n      block.apply( step.task, arguments)\r\n      if( that.currentStep === step ){\r\n        if( !step.isRunning ){\r\n          step.isRunning = true\r\n          step.scheduleNext()\r\n        }\r\n      }"],[0,"\r\n  "]],"start1":3043,"start2":3043,"length1":147,"length2":448},{"diffs":[[0,"ep\r\n"],[-1,"      step.scheduleNext()\r\n"],[0,"    "]],"start1":3568,"start2":3568,"length1":35,"length2":8}]],"length":8504,"saved":false}
{"ts":1351177999448,"patch":[[{"diffs":[[0,"== step ){\r\n"],[1,"        that.currentStep = null\r\n"],[0,"        if( "]],"start1":3361,"start2":3361,"length1":24,"length2":57}]],"length":8537,"saved":false}
{"ts":1351185095419,"patch":[[{"diffs":[[0,"ion test"],[-1,"_1"],[1,"s"],[0,"(){\r\n  f"]],"start1":7736,"start2":7736,"length1":18,"length2":17},{"diffs":[[0,"= [\"test"],[-1,"_1"],[0,""],[1,""],[0,"\"]\r\n    "]],"start1":7779,"start2":7779,"length1":18,"length2":16},{"diffs":[[0,"arts\")\r\n"],[1,"  test_1()\r\n  t( \"starts scheduler\")\r\n  L8.scheduler()\r\n\r\n"],[0,"  functi"]],"start1":7912,"start2":7912,"length1":16,"length2":74},{"diffs":[[0,"nction t"],[-1,"ask()"],[1,"est_1"],[0,"{\r\n    t"]],"start1":7982,"start2":7982,"length1":21,"length2":21},{"diffs":[[0,"   t( \"t"],[-1,"ask"],[1,"est_1"],[0,"\")\r\n    "]],"start1":7999,"start2":7999,"length1":19,"length2":21},{"diffs":[[0," function(){"],[1,"\r\n       "],[0," t( \"final\")"]],"start1":8284,"start2":8284,"length1":24,"length2":33},{"diffs":[[0,"inal"],[-1,"\")})\r\n    .end\r\n  }\r\n  task"],[1," 1\")\r\n        test_2()\r\n      })\r\n    .end\r\n  }\r\n\r\n  var test_2 = L8.scope( function test2"],[0,"()"],[1,"{"],[0,"\r\n "],[1,"   this\r\n    .step( function(){"],[0," t( "]],"start1":8311,"start2":8311,"length1":40,"length2":135},{"diffs":[[0,"tart"],[-1,"s"],[0," s"],[-1,"cheduler\")\r\n  L8.scheduler()"],[1,"tep\")})\r\n    .step( function(){ setTimeout( function() {\r\n      this.walk()\r\n    }, 0);})\r\n    .final( function(){\r\n      t( \"final 2\")\r\n    })\r\n  })\r\n"],[0,"\r\n}\r"]],"start1":8448,"start2":8448,"length1":39,"length2":161}]],"length":8820,"saved":false}
{"ts":1351185151942,"patch":[[{"diffs":[[0,"this\r\n    .step("],[1," "],[0," function(){ t( "]],"start1":8414,"start2":8414,"length1":32,"length2":33},{"diffs":[[0,"  .step("],[1," "],[0," functio"]],"start1":8466,"start2":8466,"length1":16,"length2":17},{"diffs":[[0,"out("],[-1," function() {\r\n     "],[0," thi"]],"start1":8495,"start2":8495,"length1":28,"length2":8},{"diffs":[[0,"s.walk()"],[-1,"\r\n   "],[0," }, 0);}"]],"start1":8503,"start2":8503,"length1":21,"length2":16}]],"length":8797,"saved":false}
{"ts":1351185220776,"patch":[[{"diffs":[[0,"is\r\n  try{\r\n"],[1,"    if( this.block ){\r\n  "],[0,"    this.blo"]],"start1":3821,"start2":3821,"length1":24,"length2":49},{"diffs":[[0,"this.task)\r\n"],[1,"    }\r\n"],[0,"    this.sch"]],"start1":3880,"start2":3880,"length1":24,"length2":31}]],"length":8829,"saved":false}
{"ts":1351185510799,"patch":[[{"diffs":[[0," true\r\n}\r\n\r\n"],[1,"L8.scope = function scope( fn ){\r\n  return function (){\r\n    try{\r\n      this.begin\r\n        fn()\r\n      this.end\r\n    }catch( e){\r\n      this.end\r\n      throw e\r\n    }\r\n  }\r\n}\r\n\r\n"],[0,"function Ste"]],"start1":1309,"start2":1309,"length1":24,"length2":204}]],"length":9009,"saved":false}
{"ts":1351185535453,"patch":[[{"diffs":[[0,"throw e\r\n    }\r\n"],[1,"    return this\r\n"],[0,"  }\r\n}\r\n\r\nfuncti"]],"start1":1475,"start2":1475,"length1":32,"length2":49}]],"length":9026,"saved":false}
{"ts":1351185869574,"patch":[[{"diffs":[[0,"n test_1"],[1,"()"],[0,"{\r\n    t"]],"start1":8216,"start2":8216,"length1":16,"length2":18}]],"length":9028,"saved":false}
{"ts":1351185966166,"patch":[[{"diffs":[[0,"s.walk()"],[-1," }"],[0,", 0);})\r"]],"start1":8734,"start2":8734,"length1":18,"length2":16}]],"length":9026,"saved":false}
{"ts":1351185999877,"patch":[[{"diffs":[[0,"t( \"start step\")"],[1," "],[0,"})\r\n      .step("]],"start1":8287,"start2":8287,"length1":32,"length2":33},{"diffs":[[0,"{ t( \"step\")"],[1," "],[0,"})\r\n      .s"]],"start1":8332,"start2":8332,"length1":24,"length2":25},{"diffs":[[0,"p done\")"],[1," "],[0,"})\r\n    "]],"start1":8492,"start2":8492,"length1":16,"length2":17},{"diffs":[[0,"t step\")"],[1," "],[0,"})\r\n    "]],"start1":8686,"start2":8686,"length1":16,"length2":17},{"diffs":[[0,"lk(), 0)"],[-1,";"],[1," "],[0,"})\r\n    "]],"start1":8742,"start2":8742,"length1":17,"length2":17}]],"length":9030,"saved":false}
{"ts":1351186034198,"patch":[[{"diffs":[[0,"000\r\n)\r\ntest"],[-1,"_1"],[1,"s"],[0,"()\r\ntrace( \""]],"start1":8993,"start2":8993,"length1":26,"length2":25}]],"length":9029,"saved":false}
{"ts":1351186561806,"patch":[[{"diffs":[[0,"nction (){\r\n"],[1,"    var task = CurrentStep ? CurrentStep.task : L8\r\n"],[0,"    try{\r\n  "]],"start1":1366,"start2":1366,"length1":24,"length2":76},{"diffs":[[0,"\n      t"],[-1,"his"],[1,"ask"],[0,".begin\r\n"]],"start1":1439,"start2":1439,"length1":19,"length2":19},{"diffs":[[0,"   fn()\r\n      t"],[-1,"his"],[1,"ask"],[0,".end\r\n    }catch"]],"start1":1463,"start2":1463,"length1":35,"length2":35},{"diffs":[[0,"\n      t"],[-1,"his"],[1,"ask"],[0,".end\r\n  "]],"start1":1504,"start2":1504,"length1":19,"length2":19},{"diffs":[[0,"return t"],[-1,"his"],[1,"ask"],[0,"\r\n  }\r\n}"]],"start1":1547,"start2":1547,"length1":19,"length2":19}]],"length":9081,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351186712628,"patch":[[{"diffs":[[0,"\"util\")\r"],[1,"\nUtil.debug( \"entering l8.js\")\r"],[0,"\n\r\nfunct"]],"start1":160,"start2":160,"length1":16,"length2":47}]],"length":9112,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351188811470,"patch":[[{"diffs":[[0,"      fn"],[-1,"("],[1,".apply( task"],[0,")\r\n     "]],"start1":1491,"start2":1491,"length1":17,"length2":28}]],"length":9123,"saved":false}
{"ts":1351190344877,"patch":[[{"diffs":[[0,"= true\r\n"],[1,"  this.isDone      = false\r\n"],[0,"  this.e"]],"start1":678,"start2":678,"length1":16,"length2":44},{"diffs":[[0,"this\r\n})\r\n\r\n"],[1,"Task.__defineGetter__( \"done\", function(){\r\n  return this.isDone\r\n})\r\n\r\n"],[0,"Task.step = "]],"start1":2798,"start2":2798,"length1":24,"length2":96},{"diffs":[[0,")\r\n  }\r\n"],[1,"  if( this.done ){\r\n    throw \"Can't add a new step to, task is done\"\r\n  }\r\n"],[0,"  var pa"]],"start1":3024,"start2":3024,"length1":16,"length2":92},{"diffs":[[0,": sub task\r\n"],[1,"    task.isDone = true\r\n"],[0,"    if( task"]],"start1":4719,"start2":4719,"length1":24,"length2":48}]],"length":9323,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351191357519,"patch":[[{"diffs":[[0,"k : L8\r\n"],[1,"  if( task.done || task === L8){\r\n    task = new Task( L8)\r\n  }\r\n"],[0,"  task.b"]],"start1":2370,"start2":2370,"length1":16,"length2":81},{"diffs":[[0,"tep)\r\n  return t"],[-1,"his"],[1,"ask"],[0,"\r\n})\r\n\r\nTask.__d"]],"start1":2475,"start2":2475,"length1":35,"length2":35},{"diffs":[[0,"var "],[-1,"step  = CurrentStep\r\n  var task  = step ? step.task : L8"],[1,"task  = this"],[0,"\r\n  "]],"start1":2547,"start2":2547,"length1":64,"length2":20},{"diffs":[[0,"add "],[-1,"a "],[0,"new step"],[-1," to"],[0,", ta"]],"start1":3090,"start2":3090,"length1":21,"length2":16}]],"length":9339,"saved":false}
{"ts":1351191447195,"patch":[[{"diffs":[[0," top != "],[-1,"ste"],[1,"to"],[0,"p ){\r\n"],[1,"    // TODO: check balance\r\n"],[0,"    thro"]],"start1":2640,"start2":2640,"length1":25,"length2":52}]],"length":9366,"saved":false}
{"ts":1351191721549,"patch":[[{"diffs":[[0," try{\r\n     "],[1," task ="],[0," task.begin\r"]],"start1":1492,"start2":1492,"length1":24,"length2":31},{"diffs":[[0,"k === L8"],[1," "],[0,"){\r\n    "]],"start1":2407,"start2":2407,"length1":16,"length2":17}]],"length":9374,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351191996471,"patch":[[{"diffs":[[0,"\r\n    try{\r\n"],[1,"      if( block ){\r\n  "],[0,"      block."]],"start1":3797,"start2":3797,"length1":24,"length2":46},{"diffs":[[0,"ments)\r\n"],[1,"      }\r\n"],[0,"      if"]],"start1":3865,"start2":3865,"length1":16,"length2":25}]],"length":9405,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351192633027,"patch":[[{"diffs":[[0,".sleep( "],[-1,"20"],[1,"1"],[0,"00)\r\n   "]],"start1":8785,"start2":8785,"length1":18,"length2":17}]],"length":9404,"saved":false}
{"ts":1351192746874,"patch":[[{"diffs":[[0,"{ t( \"start step"],[1," 1"],[0,"\") })\r\n      .st"]],"start1":8661,"start2":8661,"length1":32,"length2":34},{"diffs":[[0," \"start step"],[1," 2"],[0,"\") })\r\n    ."]],"start1":9057,"start2":9057,"length1":24,"length2":26}]],"length":9408,"saved":false}
{"ts":1351192824689,"patch":[[{"diffs":[[0,"k(), 0) })\r\n"],[1,"    .step(  function(){ t( \"sleep done\"))\r\n"],[0,"    .final( "]],"start1":9122,"start2":9122,"length1":24,"length2":67}]],"length":9451,"saved":false}
{"ts":1351192839333,"patch":[[{"diffs":[[0,"){ t( \"sleep"],[1,"/timeout"],[0," done\"))\r\n  "]],"start1":9155,"start2":9155,"length1":24,"length2":32}]],"length":9459,"saved":false}
{"ts":1351192860197,"patch":[[{"diffs":[[0,"t done\")"],[1," }"],[0,")\r\n    ."]],"start1":9174,"start2":9174,"length1":16,"length2":18}]],"length":9461,"saved":false}
{"ts":1351193034901,"patch":[[{"diffs":[[0,"r()\r\n\r\n "],[1," var test_1 ="],[0," functio"]],"start1":8576,"start2":8576,"length1":16,"length2":29},{"diffs":[[0,"ion test"],[-1,"_"],[0,"1(){\r\n  "]],"start1":8603,"start2":8603,"length1":17,"length2":16}]],"length":9473,"saved":false}
{"ts":1351193121258,"patch":[[{"diffs":[[0,"s\")\r"],[-1,"\n  test_1()\r\n  t( \"starts scheduler\")\r\n  L8.scheduler()\r"],[0,"\n\r\n "]],"start1":8520,"start2":8520,"length1":64,"length2":8},{"diffs":[[0,"})\r\n  })\r\n\r\n"],[1,"  test_1()\r\n  t( \"starts scheduler\")\r\n  L8.scheduler()\r\n"],[0,"}\r\n\r\ntrace( "]],"start1":9193,"start2":9193,"length1":24,"length2":80}]],"length":9473,"saved":false}
{"ts":1351193239202,"patch":[[{"diffs":[[0,"    "],[-1,"})\r\n  })"],[1,"  test_last()\r\n    })\r\n  })\r\n\r\n  var test_last = function(){\r\n    trace( \"SUCCESS!!! all tests ok\")\r\n  }"],[0,"\r\n\r\n"]],"start1":9189,"start2":9189,"length1":16,"length2":112}]],"length":9569,"saved":false}
{"ts":1351193313293,"patch":[[{"diffs":[[0,"unt_down){\r\n"],[1,"      trace( \"exiting...\")\r\n"],[0,"      proces"]],"start1":9481,"start2":9481,"length1":24,"length2":52}]],"length":9597,"saved":false}
