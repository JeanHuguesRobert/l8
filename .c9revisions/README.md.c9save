{"ts":1351024727291,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"l8\n==\n\nLight task manager for javascript"]],"start1":0,"start2":0,"length1":0,"length2":40}]],"length":40}
{"contributors":[],"silentsave":false,"ts":1351024733131,"patch":[[{"diffs":[[0,"l8"],[1,"\r"],[0,"\n=="],[-1,"\n"],[1,"\r\n\r"],[0,"\nLig"]],"start1":0,"start2":0,"length1":10,"length2":13},{"diffs":[[0,"vascript"],[1,"\r\n\r\nSchedule the execution of multiple \"tasks\". A task is made of \"steps\", much\r\nlike a function is made of statements. Tasks can nest, much like blocks of\r\nstatements. The main flow control structures are the sequential execution of\r\nsteps, steps that loop until they exit, steps that wait for something and\r\nerror propagation similar to exception handling.\r\n\r\nExecution goes from \"step\" to \"step\" by way of \"walk\". If one cannot walk a\r\nstep, one can wait for something and retry later.\r\n\r\n  l8.begin              -- enter new scope\r\n    .scope( function )  -- return the L8 scope guarded version of a function\r\n    .step( block )      -- queue a new step\r\n    .walk( block )      -- walk a step, at most once by step\r\n    .loop               -- enter a non blocking loop, made of iterative steps\r\n    .next               -- enter next iteration step in a non blocking loop\r\n    .repeat( block )    -- enter a blocking loop\r\n    .restart            -- like \"continue\", for blocking loops\r\n    .exit               -- like \"break\", exit blocking loop or task\r\n    .task               -- return current task\r\n    .parent             -- return parent task\r\n    .tasks              -- return sub tasks\r\n    .top                -- return top task of sub task\r\n    .state              -- return state of task, I->[Q|R]*->C/E/D\r\n    .raise( error )     -- raise an error in task\r\n    .spawn( block )     -- starts a new sub task\r\n    .queue()            -- schedule a new sub task\r\n    .cancel             -- cancel task & its sub tasks, brutal\r\n    .stop               -- gentle cancel\r\n    .timeout( milli )   -- cancel task if not done in time\r\n    .delay( milli )     -- block for a while, then reschedule step\r\n    .wait( lock )       -- queue step until some lock opens, then retry\r\n    .resume             -- resume execution of a task waiting at some step\r\n    .stopping           -- true after a gentle cancel, until task is done\r\n    .failed             -- true if task done but with an error\r\n    .succeed            -- true if task done without error\r\n    .done               -- true if task done, else it either wait or runs\r\n    .running            -- true if task not done\r\n    .waiting            -- true if task waiting while running (ie is queued)\r\n    .err                -- returns last raised error\r\n    .canceled           -- true if task was canceled\r\n    .stopped            -- true if task was gently canceled (gracefull)\r\n    .l8                 -- return global L8 object\r\n    .then( ... )        -- Promise/A protocol\r\n    .error( block )     -- block to run when task is done but with error\r\n    .progress( block )  -- block to run when some task is done\r\n    .final( block )     -- block to run when task is all done\r\n    .end                -- leave scope or loop, return current task\r\n\r\nTBD: semaphores, locks, message queues, signals, etc...\r\n\r\nExamples\r\n--------\r\n\r\n  function fetch_this_and_that( a, b, callback ){\r\n    var result_a = null\r\n    var result_b = null\r\n    // Hypothetical synchrone version\r\n    // result_a = fetch( a)\r\n    // if( !result_a.err ){\r\n    //   result_b = fetch( b)\r\n    // }\r\n    // callback( result_a.err || result_b.err, result_b.content)\r\n  l8.begin\r\n    .step( function(){\r\n      fetch(\r\n        a,\r\n        this.walk( function( err, content ){\r\n          result_a = { err: err, content: content }\r\n        })\r\n      )\r\n    })\r\n    .step( function(){\r\n      if( result_a.err ) this.raise( result_a.err)\r\n      fetch(\r\n        b,\r\n        this.walk( function( err, content ){\r\n          result_b = { err: err, content: content }\r\n        })\r\n      )\r\n    })\r\n    .final( function(){ callback( this.err, result_b) }) \r\n  .end}\r\n  \r\n  Coffeescript, shorter, also thanks to scope() functor\r\n  fetch_this_and_that = l8.scope (a,b,cb) ->\r\n    r_a = r_b = undefined \r\n    @step  -> fetch a, @walk (err,content) -> r_a = {err,content}\r\n    @step  ->\r\n      @raise r_a.err if r_a.err\r\n      fetch b, @walk (err,content) -> r_b = {err,content}\r\n    @final -> cb @err, r_b.content\r\n     \r\n\r\n  function fetch_all( urls, callback ){\r\n    var results = []\r\n    l8.begin\r\n      .step( function(){\r\n        this.loop; for( var url in urls ){\r\n          this.next\r\n          fetch( url, this.spawn( function( err, content ){\r\n            result.push({ url: url, err: err, content: content })\r\n          }))\r\n        }\r\n        this.end\r\n      })\r\n      .final( function(){ callback( results ) })\r\n    .end\r\n  }\r\n  \r\n  fetch_all = l8.scope (urls, callback) ->\r\n    result = []\r\n    @step ->\r\n      @loop; for url in urls\r\n        @next\r\n        fetch url, @spawn (err, content) ->\r\n          result.push {url, err, content}\r\n      @end\r\n    @final -> callback results    \r\n        \r\n\r\n  function fetch_all_seq( urls, callback ){\r\n    var results = []\r\n    l8.begin\r\n      .step( function(){\r\n        this.loop; for( var url in urls ){\r\n          this.step( function(){\r\n            fetch( url, this.walk( function( err, content ){\r\n              result.push({ url: url, err: err, content: content })\r\n            }))\r\n          })\r\n        }\r\n        this.end\r\n      })\r\n      .final( function(){ callback( results ) })\r\n    .end\r\n  }\r\n  \r\n  fetch_all_seq = l8.scope (urls, callback ) ->\r\n    results = []\r\n    @step ->\r\n      @loop; for url in urls\r\n        @step -> fetch url, @walk -> result.push {url, err, content}\r\n      @end\r\n    @final -> callback results\r\n\r\n\r\n  spider = l8.scope ( urls ) ->\r\n    queue = urls\r\n    @repeat ->\r\n      @step -> url = queue.shift\r\n      @step -> @wait 10000 if @parent.tasks.length > 10\r\n      @step ->\r\n        @exit if @stopping   \r\n        fetch url, @walk (err,urls) ->\r\n          return if err\r\n          for url in urls\r\n            queue.unshift url unless url in queue\r\n   \r\n  stop_spider -> spider.stop\r\n  "]],"start1":35,"start2":35,"length1":8,"length2":5805}]],"length":5840,"saved":false}
