// actor.js
//  actor style RPC using l8 and websockets
//
// 2013/01/07 by JHR
//
// Depends on https://github.com/natefaubion/matches.js
//   npm install matches


var l8 = require( "../src/l8.js")
var Pattern = require( "matches").pattern

l8.debug( true)
var de   = l8.de
var bug  = l8.bug
var mand = l8.mand

l8.trace( "Actor starting")

/* ----------------------------------------------------------------------------
 *  Actors, local. Aka "active objects"
 *  Actors are objects that communicate the one with the others using messages.
 *
 *  When idle, an actor simply waits for incoming messages. When a message is
 *  received, the actor can either decide to process it or decide to process
 *  it later, after some other messages. As a result, each actor has a message
 *  queue, called a "mailbox" in the actor jargon.
 *
 *  Some messages don't require an answer. They are "send type" messages. Some
 *  messages do require an answer. They are "call type" messages.
 *
 *  When it processes a "call type" message, the actor can decide to provide
 *  either a direct response or a promise to be fullfilled (or rejected) later
 *  on. Until that decision is taken, additional "call type" messages are
 *  queued. This makes it easy to "serialize" the processing of calls when that
 *  makes sense.
 *
 *  Each actor has a unique name, provided by the actor creator. All actors are
 *  remembered in a global registry where one can lookup for them. Names are
 *  in the form xx.xx.xx where the last xx is generated by the actor itself
 *  when only xx.xx. is provided at creation time.
 */

var Registry    = {}
var RegistryIds = {}

function Actor( name, delegate ){
  this.name     = name
  this.task     = null
  this.queue    = l8.queue() // aka "mailbox"
  this.backlog  = []
  this.pattern  = null
  this.delegate = null
  var previous  = null
  if( (name[name.length - 1] != ".")
  &&  (previous = this.lookup( name))
  ){
    previous.task.cancel()
  }
  this.name = this.register( name, this)
  return this
}
var ProtoActor = Actor.prototype

ProtoActor.toString = function(){ return "Actor/" + this.name }

ProtoActor.register = function( name, object ){
  if( !name ){ name = "." }
  var dot = name.lastIndexOf( ".")
  if( dot === -1 ){
    Registry[name] = object
    return name
  }
  var prefix = name.substr(    0, dot )
  var suffix = name.substring( dot + 1)
  if( suffix ){
    Registry[name] = object
    return name
  }
  var id = RegistryIds[prefix] || 0
  name += id++
  RegistryIds[prefix] = id
  Registry[name]      = object
  return name
}

ProtoActor.lookup = function( name, remove ){
  var obj = Registry[name]
  if( obj && remove ){
    delete Registry[name]
  }
  return obj
}

var SetPatternMatchOutcome

ProtoActor.match = function( msg, delegate ){
  var that  = this
  // Skip "call type" message if a call is still beeing processed
  if( msg.caller ){
    if( that.caller )return false
    that.caller = msg.caller
  }
  // Here is a message that maybe the actor is willing to process
  var rslt
  var err = null
  // Let's try to process that message
  if( delegate ){
    try{
      rslt = delegate.match( msg, this)
    }catch( e ){
      err = e
      if( err === l8.continueError )return false
    }
  }else{
    SetPatternMatchOutcome = function( e, r ){
      err  = e
      rslt = r
    }
    try{
      this.pattern.apply( this, msg.message)
    }catch( e ){
      return false
    }
    if( err === l8.continueEvent )return false
  }
  try{
    var callback = msg.caller
    if( callback && callback === that.caller ){
      that.caller = null
      callback( err, rslt)
    }
  }catch( e ){
    l8.trace( "!!! callback failure in " + this, e)
  }
  return true
}

ProtoActor.pick = function( delegate ){
// When an unexpected message is received, it gets queued. Whenever the actor
// attempts to receive a new message, these queued messages are proposed first.
// Such queued messages are a backlog and it is the programmer's responsability
// to make sure that the backlog does not grow much or else performances will
// suffer.
  var list  = this.backlog
  var len   = list.length
  if( !len )return false
  var empty = false
  var found = false
  var msg
  // Loop until nothing processable is found
  while( true ){
    // Scan queued messages, old ones first
    for( var ii ; ii < len ; ii++ ){
      // Skip emptry slot of removed messages
      if( !(msg = list[ii]) )continue;
      // The backlog is not empty, we'll have to wait to reset it
      empty = false
      if( !this.match( msg, delegate) )continue
      found    = true
      list[ii] = null
      break
    }
    // If a message was processed, restart scan, older messages first
    if( !found )break
    found = false
  }
  // When the backlog is made of empty slots, it's time to reset it
  if( empty ){
    this.backlog = []
  }
  return found
}

ProtoActor.act = function( delegate, after, timeout, loop ){
  var that = this
  l8.repeat( function(){
    // First, check backlog
    this.step( function(){
      if( that.pick( delegate) ){
        if( loop )this.continue
        this.break
      }
    // If no match, wait for a new message
    }).step( function(){
      if( timeout === 0 && that.queue.empty ){
        if( after ){
          after.call( that)
        }
        this.continue
      }
      that.queue.get()
    // Either a match or add to backlog
    }).step( function( msg ){
       if( !that.match( msg, delegate) ){
        l8.de&&bug.apply( log, ["backlog"].concat( msg))
        that.backlog.push( msg)
      }
      if( !loop ) this.break
    })
  })
  .failure( function( e ){
     l8.trace( "Actor: " + that, "Unexpected error", e)
  })
}

ProtoActor.__defineGetter__( "callback" , function(){
  var caller = this.caller
  this.caller = null
  return caller
})

ProtoActor.receive = function( pattern, options ){
// Define new behavior of actor using patterns
  // Restore current pattern when task terminates
  var previous_pattern = this.pattern
  var that = this
  if( !options ){
    options = {}
  }
  this.task._task( function(){
    this.defer( function(){ that.pattern = previous_pattern})
    var after   = options.after   || pattern.after 
    var timeout = options.timeout || pattern.timeout
    var loop    = options.loop    || pattern.loop
    // When pattern can act, delegate to it 
    if( pattern.match ){
      return that.act( pattern,          after, timeout, loop)
    }else if( pattern.delegate ){
      return that.act( pattern.delegate, after, timeout, loop)
    }
    delete pattern.after
    delete pattern.timeout
    delete pattern.loop
    // Encapsulate "matches.js" pattern to handle exceptions my way
    for( var attr in pattern ){
      if( attr === 'after' ){
        after = pattern[attr]
        continue
      }
      if( attr === 'timeout' ){
        timeout = pattern[attr]
        continue
      }
      pattern[attr] = (function( block){
        return function(){
          var rslt
          var err = null
          try{
            rslt == block.apply( this, arguments)
          }catch( e ){
            err = e
          }
          SetPatternMatchOutcome( err, rslt)
        }
      })( pattern[attr])
    }
    that.pattern = Pattern( pattern)
    that.act( after, timeout)
  })
}

ProtoActor.send = function(){
  this.queue.put( {message:Array.prototype.slice.call( arguments, 0)})
  return this
}

ProtoActor.call = function( caller, message ){
// 'caller' is a function( err, rslt) callback.
  this.queue.put( {caller:caller,message:message})
}

function MakeActorConstructor( name, pattern ){
  return function(){
    de&&bug( "create actor " + name)
    var act = new Actor( name)
    var task = l8._spawn( function(){
      task.var( "actor", act)
      task.step( function(){ act.receive( pattern, {loop:true}) })
      task.step( function(){ task.join() })
    })
    return act.task = task
  }
}

/* ----------------------------------------------------------------------------
 *  Role class
 *  When an actor plays a role, it's role defines it's behavior based on the
 *  available methods of the role.
 *  This class can be the base class of user defined sub classes.
 *  Alternatively, one can instantiate a role with a delegate, in that case
 *  it's the delegate methods that define the ultimate behavior of the actor.
 *  
 */

function Role( options ){
  this.delegate = options && options.delegate
  this.sync     = options && options.sync
  this.actor    = null
  this.task     = options && options.task
}
var ProtoRole = Role.prototype

function MakeRole( options ){
  return new Role( options)
}

ProtoRole.match = function( msg, actor ){
  var that     = this
  MakeRole.current = that
  that.actor   = actor
  var verb = msg.message[0]
  var callback
  function apply(){
    var target = that.delegate || that
    var target_method = target[verb]
    if( target_method ){
      msg.message.unshift()
    }else{
      target_method = target["catch"]
    }
    return target_method.apply( target, msg.message)
  }
  if( !msg.caller ){
    if( !that.task ){
      return apply()
    }
    that.task._spawn( function(){
      apply()
    })
  }else{
    if( !that.task ){
      callback = !that.sync && actor.callback
      var rslt
      try{
        rslt = apply()
        if( rslt.then ){
          rslt.then(
            function( ok ){
              if( !callback && !(callback = actor.callback) )return
              callback( null, ok)
            },
            function( ko ){
              if( !callback && !(callback = actor.callback) )return
              callback( ko)
            }
          )
          return
        }
        try{
          if( !callback && !(callback = actor.callback) )return
          callback( null, rslt)
        }catch( e ){
          l8.trace( "!!! unexpected callback error in " + actor, e)
        }
      }catch( err ){
        try{
          if( !callback && !(callback = actor.callback) )return
          callback( err)
        }catch( e ){
          l8.trace( "!!! unexpected callback error in " + actor, e)          
        }
      }
      return
    }
    that.task._spawn( function(){
      callback = !that.sync && actor.callback
      l8.step( function(){ that[verb].apply( that, msg)})
      l8.final( function( err, rslt ){
        try{
          if( !callback && !(callback = actor.callback) )return
          callback( err, rslt)
        }catch( e ){
          l8.trace( "!!! unexpected callback error in " + actor, e)
        }
      })
    })
  }
}

/* ----------------------------------------------------------------------------
 *  ProxyActor is a proxy for an actor that lives in a remote stage
 */

var AllConnections = {}
var AllCalls       = {}
var NextCallbackId = 0

function ProxyActor( address, name ){
  var actor = this
  this.address = address
  this.name    = name
  this.connection = AllConnections[address]
  if( !this.connection ){
    var promise = l8.promise()
    this.connection = AllConnections[address] = promise
    var socket = SocketIo.connect( address)
    socket.on( 'connect',        function(){ promise.resolve()})
    socket.on( 'connect_failed', function(){
      this.connection = AllConnections[address] = null
      promise.reject()
    })
    socket.on( 'ack', function( data ){
      actor.ack.apply( this, data)
    })
  }
}

ProtoProxyActor = ProxyActor.prototype

ProtoProxyActor.send = function(){
  var that = this
  var promise = l8.promise()
  this.connection.then(
    function( conn ){
      conn.emit( "send", {name:that.name,send:arguments})
      promise.resolve()
    },
    function(){ promise.reject() }
  )
  return promise
}

ProtoProxyActor.call = function(){
  return this.apply( arguments)
}

ProtoProxyActor.apply = function( args ){
  var that = this
  var promise = l8.promise()
  var cb_id = NextCallbackId++
  this.connection.then(
    function( conn ){
      conn.emit( "call", {name:that.name,call:args,cb:cb_id})
      AllPromises[cb_id] = promise
    },
    function(){ promise.reject() }
  )
  return promise
}

ProtoProxyActor.act = function( cb_id, err, rslt ){
  if( err ){
    AllCalls[cb_id].reject( err)
  }else{
    AllCalls[cb_id].resolve( rslt)
  }
}


/*
 *  Exports are added to existing l8 object
 */
 
l8.Actor         = MakeActorConstructor
l8.Actor.lookup  = ProtoActor.lookup
l8.Actor.all     = Registry
l8.proto.__defineGetter__( "actor", function(){ return this.get( "actor")})
l8.Role          = Role
l8.role          = MakeRole

/*
 *  Example. A "logging" actor
 */
 
var Logger = l8.Actor( "l8_logger", {
  '"error", x': function( x ){ return l8.trace( "Error: " + x) },
  'x':          function( x ){ return l8.trace( x) },
  '"throw", e': function( e ){ l8.trace( "throw...", e); throw e }
  //'...': function(){ l8.trace( "unsupported) }
})

function test_it(){
  l8.trace( "Start Logger")
  Logger()
  var mylog = l8.Actor.lookup( "l8_logger")
  de&&mand( mylog)
  mylog.task.then(
    function(){ l8.trace( "actor done")},
    function(){ l8.trace( "actor dead")}
  )
  mylog.send( "Hello")
  mylog.send( "error", "is ok")
  mylog.send( "does not understand", "this")
  mylog.send( "throw", "something that kills")
}

/*
 *  Example. A "logging" actor using a delegate playing a role.
 *  Note: another example could create a subclass of l8.Role instead of using
 *  the generic Role class with a delegate.
 */
 
var LoggerBis = l8.Actor( "l8_logger", l8.role( {
  delegate:{
    "Hello": function(){
      l8.trace( "Hello")
    },
    trace: function(){
      l8.trace.apply( l8, arguments)
    },
    error: function(){
      var msg = Array.prototype.slice.call( arguments, 0)
      msg[0] = "Error: " + msg[0]
      l8.trace.apply( l8, msg)
    },
    catch: function(){
      var msg = Array.prototype.slice.call( arguments, 0)
      msg[0] = "Catch: " + msg[0]
      l8.trace.apply( l8, msg)
    },
    throw: function( e ){
      l8.trace( "throw...", e); throw e
    }
  }
}))

l8.task( function(){
  l8.trace( "Scheduling test")
  l8.step( function(){ test_it() })
  l8.step( function(){ l8.sleep( 1000) })
  l8.step( function(){ Logger = LoggerBis; test_it() })
  l8.step( function(){ l8.sleep( 1000) })
  l8.failure( function( e ){ l8.trace( "!!! unexpected error", e) })
})

 
l8.countdown( 5)

/* ---------------------------------------------------------------------------
 *  Stages, with actors in them. Each nodejs process (or browser) is a stage.
 */
 
/* ---------------------------------------------------------------------------
 *  Campaign, where actors on multiple stages cooperate
 */









